<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by db* CODECOP using the genmodel option -->
<rules>
	<rule>
		<key>G-0000</key>
		<name><![CDATA[G-0000: Avoid using the NOSONAR marker.]]></name>
		<internalKey>G-0000</internalKey>
		<severity>INFO</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The NOSONAR marker is helpful to quickly exclude false positives.
			But when used often and increasingly this is a potential sign of hidden quality issues.</p>
			<h2>Bad</h2>
<pre>declare
   l_value pls_integer := null; -- NOSONAR
begin
   sys.dbms_output.put_line(l_value);
end;
/

-- Still bad
declare
   l_value pls_integer := null;
begin
   sys.dbms_output.put_line(l_value);
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_value pls_integer;
begin
   sys.dbms_output.put_line(l_value);
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-1010</key>
		<name><![CDATA[G-1010: Try to label your sub blocks.]]></name>
		<internalKey>G-1010</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>It's a good alternative for comments to indicate the start and end of a named processing.</p>
			<h2>Bad</h2>
<pre>begin
   begin
      null;
   end;

   begin
      null;
   end;
end;
/</pre>
			<h2>Good</h2>
<pre>begin
   &lt;&lt;prepare_data&gt;&gt;
   begin
      null;
   end prepare_data;

   &lt;&lt;process_data&gt;&gt;
   begin
      null;
   end process_data;
end good;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-1020</key>
		<name><![CDATA[G-1020: Always have a matching loop or block label.]]></name>
		<internalKey>G-1020</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Use a label directly in front of loops and nested anonymous blocks:</p>
			<ul>
			   <li>To give a name to that portion of code and thereby self-document what it is doing.</li>
			   <li>So that you can repeat that name with the <code>end<code> statement of that block or loop.</li>
			</ul>
			<h2>Bad</h2>
<pre>declare
   i            integer;
   co_min_value constant integer := 1;
   co_max_value constant integer := 10;
   co_increment constant integer := 1;
begin
   &lt;&lt;prepare_data&gt;&gt;
   begin
      null;
   end;

   &lt;&lt;process_data&gt;&gt;
   begin
      null;
   end;

   i := co_min_value;
   &lt;&lt;while_loop&gt;&gt;
   while (i &lt;= co_max_value)
   loop
      i := i + co_increment;
   end loop;

   &lt;&lt;basic_loop&gt;&gt;
   loop
      exit basic_loop;
   end loop;

   &lt;&lt;for_loop&gt;&gt;
   for i in co_min_value..co_max_value
   loop
      sys.dbms_output.put_line(i);
   end loop;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   i            integer;
   co_min_value constant integer := 1;
   co_max_value constant integer := 10;
   co_increment constant integer := 1;
begin
   &lt;&lt;prepare_data&gt;&gt;
   begin
      null;
   end prepare_data;

   &lt;&lt;process_data&gt;&gt;
   begin
      null;
   end process_data;

   i := co_min_value;
   &lt;&lt;while_loop&gt;&gt;
   while (i &lt;= co_max_value)
   loop
      i := i + co_increment;
   end loop while_loop;

   &lt;&lt;basic_loop&gt;&gt;
   loop
      exit basic_loop;
   end loop basic_loop;

   &lt;&lt;for_loop&gt;&gt;
   for i in co_min_value..co_max_value
   loop
      sys.dbms_output.put_line(i);
   end loop for_loop;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-1030</key>
		<name><![CDATA[G-1030: Avoid defining variables that are not used.]]></name>
		<internalKey>G-1030</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Unused variables decrease the maintainability and readability of your code.</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   procedure my_proc is
      l_last_name      employees.last_name%type;
      l_first_name     employees.first_name%type;
      co_department_id constant departments.department_id%type := 10;
      e_good           exception;
   begin
      select e.last_name
        into l_last_name
        from employees e
       where e.department_id = co_department_id;
   exception
      when no_data_found then
         null; -- handle_no_data_found;
      when too_many_rows then
         null; -- handle_too_many_rows;
   end my_proc;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   procedure my_proc is
      l_last_name      employees.last_name%type;
      co_department_id constant departments.department_id%type := 10;
      e_good           exception;
   begin
      select e.last_name
        into l_last_name
        from employees e
       where e.department_id = co_department_id;

      raise e_good;
   exception
      when no_data_found then
         null; -- handle_no_data_found;
      when too_many_rows then
         null; -- handle_too_many_rows;
   end my_proc;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-1040</key>
		<name><![CDATA[G-1040: Avoid dead code.]]></name>
		<internalKey>G-1040</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Any part of your code, which is no longer used or cannot be reached, should be eliminated from
			your programs to simplify the code.</p>
			<h2>Bad</h2>
<pre>declare
   co_dept_purchasing constant departments.department_id%type := 30;
begin
   if 2 = 3 then
      null; -- some dead code here
   end if;

   null; -- some enabled code here

   &lt;&lt;my_loop&gt;&gt;
   loop
      exit my_loop;
      null; -- some dead code here
   end loop my_loop;

   null; -- some other enabled code here

   case
      when 1 = 1 and 'x' = 'y' then
         null; -- some dead code here
      else
         null; -- some further enabled code here
   end case;

   &lt;&lt;my_loop2&gt;&gt;
   for r_emp in (
      select last_name
        from employees
       where department_id = co_dept_purchasing
          or commission_pct is not null
         and 5 = 6
   ) 
   -- "or commission_pct is not null" is dead code 
   loop
      sys.dbms_output.put_line(r_emp.last_name);
   end loop my_loop2;

   return;
   null; -- some dead code here
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   co_dept_admin constant dept.deptno%type := 10;
begin
   null; -- some enabled code here
   null; -- some other enabled code here
   null; -- some further enabled code here

   &lt;&lt;my_loop2&gt;&gt;
   for r_emp in (
      select last_name
        from employees
       where department_id = co_dept_admin
          or commission_pct is not null
   )
   loop
      sys.dbms_output.put_line(r_emp.last_name);
   end loop my_loop2;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-1050</key>
		<name><![CDATA[G-1050: Avoid using literals in your code.]]></name>
		<internalKey>G-1050</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Literals are often used more than once in your code. Having them defined as a constant reduces
			typos in your code and improves the maintainability.</p>
			<p>All constants should be collated in just one package used as a library. If these constants should be
			used in SQL too it is good practice to write a deterministic package function for every constant.</p>
			<p>In specific situations this rule could lead to an extreme plethora of constants, for example if you
			use Logger like logger.append_param(p_params =>l_params, p_name => 'p_param1_todo', p_val => p_param1_todo);,
			where the value for p_name always should be the name of the variable that is passed to p_val.
			For such cases it would be overkill to add constants for every single variable name you are logging,
			so if you use Logger or similar, consider making that an exception to the rule, just document exactly
			which exceptions you will allow and stick to them.</p>
			<h2>Bad</h2>
<pre>declare
   l_job employees.job_id%type;
begin
   select e.job_id
     into l_job
     from employees e
    where e.manager_id is null;

   if l_job = 'AD_PRES' then
      null;
   end if;
exception
   when no_data_found then
      null; -- handle_no_data_found;
   when too_many_rows then
      null; -- handle_too_many_rows; 
end;
/</pre>
			<h2>Good</h2>
<pre>create or replace package constants_up is
   co_president constant employees.job_id%type := 'AD_PRES';
end constants_up;
/

declare
   l_job employees.job_id%type;
begin
   select e.job_id
     into l_job
     from employees e
    where e.manager_id is null;

   if l_job = constants_up.co_president then
      null;
   end if;
exception
   when no_data_found then
      null; -- handle_no_data_found;
   when too_many_rows then
      null; -- handle_too_many_rows; 
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-1060</key>
		<name><![CDATA[G-1060: Avoid storing ROWIDs or UROWIDs in database tables.]]></name>
		<internalKey>G-1060</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>It is an extremely dangerous practice to store <code>rowid</code>'s in a table, except for some very limited
			scenarios of runtime duration. Any manually explicit or system generated implicit table
			reorganization will reassign the row's <code>rowid</code> and break the data consistency.</p>
			<p>Instead of using <code>rowid</code> for later reference to the original row one should use the primary key
			column(s).</p>
			<h2>Bad</h2>
<pre>begin
   insert into employees_log (
      employee_id
     ,last_name
     ,first_name
     ,rid
   )
   select employee_id
         ,last_name
         ,first_name
         ,rowid
     from employees;
end;
/</pre>
			<h2>Good</h2>
<pre>begin
   insert into employees_log (
      employee_id
     ,last_name
     ,first_name
   )
   select employee_id
         ,last_name
         ,first_name
     from employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-1070</key>
		<name><![CDATA[G-1070: Avoid nesting comment blocks.]]></name>
		<internalKey>G-1070</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Having an end-of-comment within a block comment will end that block-comment. This does not
			only influence your code but is also very hard to read.</p>
			<h2>Bad</h2>
<pre>begin
   /* comment one -- nested comment two */
   null;
   -- comment three /* nested comment four */
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>begin
   /* comment one, comment two */
   null;
   -- comment three, comment four
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-1080</key>
		<name><![CDATA[G-1080: Avoid using the same expression on both sides of a relational comparison operator or a logical operator.]]></name>
		<internalKey>G-1080</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Using the same value on either side of a binary operator is almost always a mistake. In the case
			of logical operators, it is either a copy/paste error and therefore a bug, or it is simply wasted code
			and should be simplified.</p>
			<p>This rule ignores operators <code>+</code>, <code>*</code> and <code>||</code>, and expressions:
			<code>1=1<c/ode>, <code>1&lt;&gt;</<code>, <code>1!=1</code>, <code>1~=1</code> and <code>1^=1</code>.</p>
			<h2>Bad</h2>
<pre>select emp.first_name
      ,emp.last_name
      ,emp.salary
      ,emp.hire_date
  from employees emp
 where emp.salary &gt; 3000
    or emp.salary &gt; 3000
 order by emp.last_name,emp.first_name;</pre>
			<h2>Good</h2>
<pre>select emp.first_name
      ,emp.last_name
      ,emp.salary
      ,emp.hire_date
  from employees emp
 where emp.salary &gt; 3000
 order by emp.last_name,emp.first_name;</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-2110</key>
		<name><![CDATA[G-2110: Try to use anchored declarations for variables, constants and types.]]></name>
		<internalKey>G-2110</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Changing the size of the database column last_name in the employees table from <code>varchar2(20)</code> 
			to <code>varchar2(30)</code> will result in an error within your code whenever a value larger than the hard 
			coded size is read from the table. This can be avoided using anchored declarations.</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   procedure my_proc is
      l_last_name  varchar2(20 char);
      co_first_row constant integer := 1;
   begin
      select e.last_name
        into l_last_name
        from employees e
       where rownum = co_first_row;
   exception
      when no_data_found then
         null; -- handle no_data_found
      when too_many_rows then
         null; -- handle too_many_rows (impossible)
   end my_proc;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   procedure my_proc is
      l_last_name  employees.last_name%type;
      co_first_row constant integer := 1;
   begin
      select e.last_name
        into l_last_name
        from employees e
       where rownum = co_first_row;
   exception
      when no_data_found then
         null; -- handle no_data_found
      when too_many_rows then
         null; -- handle too_many_rows (impossible)
   end my_proc;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-2120</key>
		<name><![CDATA[G-2120: Try to have a single location to define your types.]]></name>
		<internalKey>G-2120</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Single point of change when changing the data type. No need to argue where to define types or
			where to look for existing definitions.</p>
			<p>A single location could be either a type specification package or the database (database-defined
			types).</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   procedure my_proc is
      subtype big_string_type is varchar2(1000 char);
      l_note big_string_type;
   begin
      l_note := some_function();
      do_something(l_note);
   end my_proc;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package types_up is
   subtype big_string_type is varchar2(1000 char);
end types_up;
/

create or replace package body my_package is
   procedure my_proc is
      l_note types_up.big_string_type;
   begin
      l_note := some_function();
      do_something(l_note);
   end my_proc;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-2130</key>
		<name><![CDATA[G-2130: Try to use subtypes for constructs used often in your code.]]></name>
		<internalKey>G-2130</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Single point of change when changing the data type.</p>
			<p>Your code will be easier to read as the usage of a variable/constant may be derived from its
			definition.</p>
			<p>Examples of possible subtype definitions:</p>
			<ul>
			   <li>ora_name_type - Object corresponding to the Oracle Database naming conventions (table,
			   variable, column, package, etc.).</li>
			   <li>max_vc2_type - String variable with maximal VARCHAR2 size.</li>
			   <li>array_index_type - Best fitting data type for array navigation.</li>
			   <li>id_type - Data type used for all primary key (id) columns.</li>
			</ul>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   procedure my_proc is
      l_note varchar2(1000 char);
   begin
      l_note := some_function();
      do_something(l_note);
   end my_proc;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package types_up is
   subtype big_string_type is varchar2(1000 char);
end types_up;
/

create or replace package body my_package is
   procedure my_proc is
      l_note types_up.big_string_type;
   begin
      l_note := some_function();
      do_something(l_note);
   end my_proc;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-2135</key>
		<name><![CDATA[G-2135: Avoid assigning values to local variables that are not used by a subsequent statement.]]></name>
		<internalKey>G-2135</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Expending resources calculating and assigning values to a local variable and never use the value
			subsequently is at best a waste, at worst indicative of a mistake that leads to a bug.</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   procedure my_proc is
      co_employee_id constant employees.employee_id%type := 1042;
      l_last_name    employees.last_name%type;
      l_message      varchar2(100 char);
   begin
      select emp.last_name
        into l_last_name
        from employees emp
       where emp.employee_id = co_employee_id;

      l_message := 'Hello, ' || l_last_name;
   exception
      when no_data_found then
         null; -- handle_no_data_found;
      when too_many_rows then
         null; -- handle_too_many_rows;
   end my_proc;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   procedure my_proc is
      co_employee_id constant employees.employee_id%type := 1042;
      l_last_name    employees.last_name%type;
      l_message      varchar2(100 char);
   begin
      select emp.last_name
        into l_last_name
        from employees emp
       where emp.employee_id = co_employee_id;

      l_message := 'Hello, ' || l_last_name;

      message_api.send_message(l_message);
   exception
      when no_data_found then
         null; -- handle_no_data_found;
      when too_many_rows then
         null; -- handle_too_many_rows;
   end my_proc;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-2140</key>
		<name><![CDATA[G-2140: Never initialize variables with NULL.]]></name>
		<internalKey>G-2140</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Variables are initialized to <code>null</code> by default.</p>
			<h2>Bad</h2>
<pre>declare
   l_note big_string_type := null;
begin
   sys.dbms_output.put_line(l_note);
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_note big_string_type;
begin
   sys.dbms_output.put_line(l_note);
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-2145</key>
		<name><![CDATA[G-2145: Never self-assign a variable.]]></name>
		<internalKey>G-2145</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>There is no reason to assign a variable to itself. It is either a redundant statement that should be
			removed, or it is a mistake where some other value was intended in the assignment.</p>
			<h2>Bad</h2>
<pre>declare
   l_function_result pls_integer;
   l_parallel_degree pls_integer;
begin
   l_function_result := maintenance.get_config('parallel_degree');
   l_parallel_degree := l_parallel_degree;
   do_something(l_parallel_degree);
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_function_result pls_integer;
   l_parallel_degree pls_integer;
begin
   l_function_result := maintenance.get_config('parallel_degree');
   l_parallel_degree := l_function_result;
   do_something(l_parallel_degree);
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-2150</key>
		<name><![CDATA[G-2150: Avoid comparisons with NULL value, consider using IS [NOT] NULL.]]></name>
		<internalKey>G-2150</internalKey>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The <code>null</code> value can cause confusion both from the standpoint of code review and code
			execution. You must always use the <code>is null</code> or <code>is not null</code> syntax when you need to check if
			a value is or is not <code>null</code>.</p>
			<h2>Bad</h2>
<pre>declare
   l_value integer;
begin
   if l_value = null then
      null;
   end if;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_value integer;
begin
   if l_value is null then
      null;
   end if;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-2160</key>
		<name><![CDATA[G-2160: Avoid initializing variables using functions in the declaration section.]]></name>
		<internalKey>G-2160</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>If your initialization fails, you will not be able to handle the error in your exceptions block.</p>
			<h2>Bad</h2>
<pre>declare
   co_department_id  constant integer := 100;
   l_department_name departments.department_name%type :=
      department_api.name_by_id(in_id =&gt; co_department_id);
begin
   sys.dbms_output.put_line(l_department_name);
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   co_department_id  constant integer                          := 100;
   co_unkown_name    constant departments.department_name%type := 'unknown';
   l_department_name departments.department_name%type;
begin
   &lt;&lt;init&gt;&gt;
   begin
      l_department_name := department_api.name_by_id(in_id =&gt; co_department_id);
   exception
      when value_error then
         l_department_name := co_unkown_name;
   end init;

   sys.dbms_output.put_line(l_department_name);
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-2170</key>
		<name><![CDATA[G-2170: Never overload variables.]]></name>
		<internalKey>G-2170</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The readability of your code will be higher when you do not overload variables.</p>
			<h2>Bad</h2>
<pre>begin
   &lt;&lt;main&gt;&gt;
   declare
      co_main    constant user_objects.object_name%type := 'test_main';
      co_sub     constant user_objects.object_name%type := 'test_sub';
      co_sep     constant user_objects.object_name%type := ' - ';
      l_variable user_objects.object_name%type          := co_main;
   begin
      &lt;&lt;sub&gt;&gt;
      declare
         l_variable user_objects.object_name%type := co_sub;
      begin
         sys.dbms_output.put_line(l_variable
            || co_sep
            || main.l_variable);
      end sub;
   end main;
end;
/</pre>
			<h2>Good</h2>
<pre>begin
   &lt;&lt;main&gt;&gt;
   declare
      co_main         constant user_objects.object_name%type := 'test_main';
      co_sub          constant user_objects.object_name%type := 'test_sub';
      co_sep          constant user_objects.object_name%type := ' - ';
      l_main_variable user_objects.object_name%type          := co_main;
   begin
      &lt;&lt;sub&gt;&gt;
      declare
         l_sub_variable user_objects.object_name%type := co_sub;
      begin
         sys.dbms_output.put_line(l_sub_variable
            || co_sep
            || l_main_variable);
      end sub;
   end main;
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-2180</key>
		<name><![CDATA[G-2180: Never use quoted identifiers.]]></name>
		<internalKey>G-2180</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Quoted identifiers make your code hard to read and maintain.</p>
			<h2>Bad</h2>
<pre>declare
   "sal+comm"     integer;
   "my constant"  constant integer := 1;
   "my exception" exception;
begin
   "sal+comm" := "my constant";
exception
   when "my exception" then
      null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_sal_comm     integer;
   co_my_constant constant integer := 1;
   e_my_exception exception;
begin
   l_sal_comm := co_my_constant;
exception
   when e_my_exception then
      null;
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-2185</key>
		<name><![CDATA[G-2185: Avoid using overly short names for explicitly or implicitly declared identifiers.]]></name>
		<internalKey>G-2185</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>You should ensure that the name you have chosen well defines its purpose and usage. While you
			can save a few keystrokes typing very short names, the resulting code is obscure and hard for
			anyone besides the author to understand.</p>
			<h2>Bad</h2>
<pre>declare
   i integer;
   c constant integer := 1;
   e exception;
begin
   i := c;
exception
   when e then
      null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_sal_comm     integer;
   co_my_constant constant integer := 1;
   e_my_exception exception;
begin
   l_sal_comm := co_my_constant;
exception
   when e_my_exception then
      null;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-2190</key>
		<name><![CDATA[G-2190: Avoid using ROWID or UROWID.]]></name>
		<internalKey>G-2190</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Be careful about your use of Oracle Database specific data types like <code>rowid</code> and <code>urowid</code>. They might offer
			a slight improvement in performance over other means of identifying a single row (primary key or
			unique index value), but that is by no means guaranteed.</p>
			<p>Use of <code>rowid</code> or <code>urowid<c/ode> means that your SQL statement will not be portable to other SQL
			databases. Many developers are also not familiar with these data types, which can make the
			code harder to maintain.</p>
			<h2>Bad</h2>
<pre>declare
   l_department_name departments.department_name%type;
   l_rowid           rowid;
begin
   update departments
      set department_name = l_department_name
    where rowid = l_rowid;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_department_name departments.department_name%type;
   l_department_id   departments.department_id%type;
begin
   update departments
      set department_name = l_department_name
    where department_id = l_department_id;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-2210</key>
		<name><![CDATA[G-2210: Avoid declaring NUMBER variables, constants or subtypes with no precision.]]></name>
		<internalKey>G-2210</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>If you do not specify precision <code>number</code> is defaulted to 38 or the maximum supported by your
			system, whichever is less. You may well need all this precision, but if you know you do not, you
			should specify whatever matches your needs.</p>
			<h2>Bad</h2>
<pre>create or replace package body constants_up is
   co_small_increase constant number := 0.1;

   function small_increase return number is
   begin
      return co_small_increase;
   end small_increase;
end constants_up;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body constants_up is
   co_small_increase constant number(5,1) := 0.1;

   function small_increase return number is
   begin
      return co_small_increase;
   end small_increase;
end constants_up;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-2220</key>
		<name><![CDATA[G-2220: Try to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values.]]></name>
		<internalKey>G-2220</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p><code>pls_integer</code> having a length of -2,147,483,648 to 2,147,483,647, on a 32bit system.
			There are many reasons to use <code>pls_integer</code> instead of <code>number</code>:</p>
			<ul>
			   <li><code>pls_integer</code> uses less memory</li>
			   <li><code>pls_integer</code> uses machine arithmetic, which is up to three times faster than
			library arithmetic, which is used by <code>number</code>.</li>
			</ul>
			<h2>Bad</h2>
<pre>create or replace package body constants_up is
   co_big_increase constant number(5,0) := 1;

   function big_increase return number is
   begin
      return co_big_increase;
   end big_increase;
end constants_up;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body constants_up is
   co_big_increase constant pls_integer := 1;

   function big_increase return pls_integer is
   begin
      return co_big_increase;
   end big_increase;
end constants_up;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-2230</key>
		<name><![CDATA[G-2230: Try to use SIMPLE_INTEGER datatype when appropriate.]]></name>
		<internalKey>G-2230</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Restriction</h2>
			<p>Oracle Database 11g or later</p>
			<h2>Reason</h2>
			<p><code>simple_integer</code> does no checks on numeric overflow, which results in better performance
			compared to the other numeric datatypes.</p>
			<p>With Oracle Database 11g, the new data type <code>simple_integer</code> has been introduced. It is a sub-type of
			<code>pls_integer</code> and covers the same range. The basic difference is that <code>simple_integer</code> is
			always not null. When the value of the declared variable is never going to be null then you can
			declare it as <code>simple_integer</code>. Another major difference is that you will never face a numeric
			overflow using <code>simple_integer</code> as this data type wraps around without giving any error.
			<code>simple_integer</code> data type gives major performance boost over <code>pls_integer</code> when code is
			compiled in <code>native</code> mode, because arithmetic operations on <code>simple_integer</code> type are
			performed directly at the hardware level.</p>
			<h2>Bad</h2>
<pre>create or replace package body constants_up is
   co_big_increase constant number(5,0) := 1;

   function big_increase return number
      deterministic
   is
   begin
      return co_big_increase;
   end big_increase;
end constants_up;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body constants_up is
   co_big_increase constant simple_integer := 1;

   function big_increase return simple_integer
      deterministic
   is
   begin
      return co_big_increase;
   end big_increase;
end constants_up;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-2310</key>
		<name><![CDATA[G-2310: Avoid using CHAR data type.]]></name>
		<internalKey>G-2310</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p><code>char</code> is a fixed length data type, which should only be used when appropriate. <code>char</code>
			columns/variables are always filled to its specified lengths; this may lead to unwanted side
			effects and undesired results.</p>
			<h2>Bad</h2>
<pre>create or replace package types_up
is
   subtype description_type is char(200);
end types_up;
/</pre>
			<h2>Good</h2>
<pre>create or replace package types_up
is
   subtype description_type is varchar2(200 char);
end types_up;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-2320</key>
		<name><![CDATA[G-2320: Never use VARCHAR data type.]]></name>
		<internalKey>G-2320</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Do not use the <code>varchar</code> data type. Use the <code>varchar2</code> data type instead. Although the <code>varchar</code>
			data type is currently synonymous with <code>varchar2</code>, the <code>varchar</code> data type is scheduled to be
			redefined as a separate data type used for variable-length character strings compared with
			different comparison semantics.</p>
			<h2>Bad</h2>
<pre>create or replace package types_up is
   subtype description_type is varchar(200);
end types_up;
/</pre>
			<h2>Good</h2>
<pre>create or replace package types_up is
   subtype description_type is varchar2(200 char);
end types_up;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-2330</key>
		<name><![CDATA[G-2330: Never use zero-length strings to substitute NULL.]]></name>
		<internalKey>G-2330</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Today zero-length strings and <code>null</code> are currently handled identical by the Oracle Database. There is no
			guarantee that this will still be the case in future releases, therefore if you mean <code>null</code> use <code>null</code>.</p>
			<h2>Bad</h2>
<pre>create or replace package body constants_up is
   co_null_string constant varchar2(1) := '';

   function null_string return varchar2 is
   begin
      return co_null_string;
   end null_string;
end constants_up;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body constants_up is

   function empty_string return varchar2 is
   begin
      return null;
   end empty_string;
end constants_up;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-2340</key>
		<name><![CDATA[G-2340: Always define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored).]]></name>
		<internalKey>G-2340</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Changes to the <code>nls_length_semantic</code> will only be picked up by your code after a recompilation.</p>
			<p>In a multibyte environment a <code>varchar2(10)</code> definition may not necessarily hold 10 characters
			when multibyte characters are part of the value that should be stored, unless the definition was
			done using the <code>char</code> semantic.</p>
			<h2>Bad</h2>
<pre>create or replace package types_up is
   subtype description_type is varchar2(200);
end types_up;
/</pre>
			<h2>Good</h2>
<pre>create or replace package types_up is
   subtype description_type is varchar2(200 char);
end types_up;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-2410</key>
		<name><![CDATA[G-2410: Try to use boolean data type for values with dual meaning.]]></name>
		<internalKey>G-2410</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The use of <code>true</code> and <code>false</code> clarifies that this is a boolean value and makes the code easier to
			read.</p>
			<h2>Bad</h2>
<pre>declare
   co_newfile constant pls_integer := 1000;
   co_oldfile constant pls_integer := 500;
   l_bigger   pls_integer;
begin
   if co_newfile &lt; co_oldfile then
      l_bigger := constants_up.co_numeric_true;
   else
      l_bigger := constants_up.co_numeric_false;
   end if;
end;
/</pre>
			<h2>Better</h2>
<pre>declare
   co_newfile constant pls_integer := 1000;
   co_oldfile constant pls_integer := 500;
   l_bigger   boolean;
begin
   if co_newfile &lt; co_oldfile then
      l_bigger := true;
   else
      l_bigger := false;
   end if;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   co_newfile constant pls_integer := 1000;
   co_oldfile constant pls_integer := 500;
   l_bigger   boolean;
begin
   l_bigger := nvl(co_newfile &lt; co_oldfile,false);
end;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-2510</key>
		<name><![CDATA[G-2510: Avoid using the LONG and LONG RAW data types.]]></name>
		<internalKey>G-2510</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p><code>long</code> and <code>long raw</code> data types have been deprecated by the Oracle Database since version 8i - support
			might be discontinued in future Oracle Database releases.</p>
			<p>There are many constraints to <code>long</code> datatypes in comparison to the <code>lob</code> types.</p>
			<h2>Bad</h2>
<pre>create or replace package example_package is
   g_long long;
   g_raw long raw;

   procedure do_something;
end example_package;
/

create or replace package body example_package is
   procedure do_something is
   begin
      null;
   end do_something;
end example_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package example_package is
   procedure do_something;
end example_package;
/

create or replace package body example_package is
   g_long clob;
   g_raw  blob;

   procedure do_something is
   begin
      null;
   end do_something;
end example_package;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-2610</key>
		<name><![CDATA[G-2610: Never use self-defined weak ref cursor types.]]></name>
		<internalKey>G-2610</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>There is no reason to define your own weak ref cursor types, as they are not different
			from the built-in `sys_refcursor`. Introducing your own types just gives you unnecessary
			maintenance to perform.</p>
			<h2>Bad</h2>
<pre>declare
   type local_weak_cursor_type is ref cursor;
   cv_data local_weak_cursor_type;
begin
   if configuration.use_employee then
      open cv_data for
         select e.employee_id,e.first_name,e.last_name
           from employees e;
   else
      open cv_data for
         select e.emp_id,e.name
           from emp e;
   end if;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   cv_data sys_refcursor;
begin
   if configuration.use_employee then
      open cv_data for
         select e.employee_id,e.first_name,e.last_name
           from employees e;
   else
      open cv_data for
         select e.emp_id,e.name
           from emp e;
   end if;
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-3110</key>
		<name><![CDATA[G-3110: Always specify the target columns when coding an insert statement.]]></name>
		<internalKey>G-3110</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Data structures often change. Having the target columns in your insert statements will lead to
			change-resistant code.</p>
			<h2>Bad</h2>
<pre>insert into departments
values (
   departments_seq.nextval
  ,'Support'
  ,100
  ,10);</pre>
			<h2>Good</h2>
<pre>insert into departments (
   department_id
  ,department_name
  ,manager_id
  ,location_id)
values (
   departments_seq.nextval
  ,'Support'
  ,100
  ,10);</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-3115</key>
		<name><![CDATA[G-3115: Avoid self-assigning a column.]]></name>
		<internalKey>G-3115</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>There is normally no reason to assign a column to itself. It is either a redundant statement that
			should be removed, or it is a mistake where some other value was intended in the assignment.</p>
			<p>One exception to this rule can be when you attempt to fire cross edition triggers when using
			Edition Based Redefinition.</p>
			<h2>Bad</h2>
<pre>update employees
   set first_name = first_name;</pre>
			<h2>Good</h2>
<pre>update employees
   set first_name = initcap(first_name);</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-3120</key>
		<name><![CDATA[G-3120: Always use table aliases when your SQL statement involves more than one source.]]></name>
		<internalKey>G-3120</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>It is more human readable to use aliases instead of writing columns with no table information.</p>
			<p>Especially when using subqueries the omission of table aliases may end in unexpected behavior
			and result.</p>
			<h2>Bad</h2>
<pre>select last_name
      ,first_name
      ,department_name
  from employees
  join departments
 using (department_id)
 where extract(month from hire_date) = extract(month from sysdate);
 
-- If the jobs table has no employee_id column and employees has one this query will not raise
-- an error but return all rows of the employees table as a subquery is allowed to access columns
-- of all its parent tables - this construct is known as correlated subquery.
select last_name
      ,first_name
  from employees
 where employee_id in (
          select employee_id
            from jobs
           where job_title like '%Manager%'
       );</pre>
			<h2>Better</h2>
<pre>select e.last_name
      ,e.first_name
      ,d.department_name
  from employees e
  join departments d
    on (e.department_id = d.department_id)
 where extract(month from e.hire_date) = extract(month from sysdate);</pre>
			<h2>Good</h2>
<pre>-- Using meaningful aliases improves the readability of your code.
select emp.last_name
      ,emp.first_name
      ,dept.department_name
  from employees emp
  join departments dept
    on (emp.department_id = dept.department_id)
 where extract(month from emp.hire_date) = extract(month from sysdate);

-- If the jobs table has no employee_id column this query will return an error due to the directive
-- (given by adding the table alias to the column) to read the employee_id column from the jobs
-- table.
select emp.last_name
      ,emp.first_name
  from employees emp
 where emp.employee_id in (
          select j.employee_id
            from jobs j
           where j.job_title like '%Manager%'
       );</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-3130</key>
		<name><![CDATA[G-3130: Try to use ANSI SQL-92 join syntax.]]></name>
		<internalKey>G-3130</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>ANSI SQL-92 join syntax supports the full outer join. A further advantage of the ANSI SQL-92 join
			syntax is the separation of the join condition from the query filters.</p>
			<h2>Bad</h2>
<pre>select e.employee_id
      ,e.last_name
      ,e.first_name
      ,d.department_name
  from employees e
      ,departments d
 where e.department_id = d.department_id
   and extract(month from e.hire_date) = extract(month from sysdate);</pre>
			<h2>Good</h2>
<pre>select emp.employee_id
      ,emp.last_name
      ,emp.first_name
      ,dept.department_name
  from employees emp
  join departments dept
    on dept.department_id = emp.department_id
 where extract(month from emp.hire_date) = extract(month from sysdate);</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-3140</key>
		<name><![CDATA[G-3140: Try to use anchored records as targets for your cursors.]]></name>
		<internalKey>G-3140</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Using cursor-anchored records as targets for your cursors results enables the possibility of
			changing the structure of the cursor without regard to the target structure.</p>
			<h2>Bad</h2>
<pre>declare
   cursor c_employees is
      select employee_id,first_name,last_name
        from employees;
   l_employee_id employees.employee_id%type;
   l_first_name  employees.first_name%type;
   l_last_name   employees.last_name%type;
begin
   open c_employees;
   fetch c_employees into l_employee_id,l_first_name,l_last_name;
   &lt;&lt;process_employees&gt;&gt;
   while c_employees%found
   loop
      -- do something with the data
      fetch c_employees into l_employee_id,l_first_name,l_last_name;
   end loop process_employees;
   close c_employees;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   cursor c_employees is
      select employee_id,first_name,last_name
        from employees;
   r_employee c_employees%rowtype;
begin
   open c_employees;
   fetch c_employees into r_employee;
   &lt;&lt;process_employees&gt;&gt;
   while c_employees%found
   loop
      -- do something with the data
      fetch c_employees into r_employee;
   end loop process_employees;
   close c_employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-3145</key>
		<name><![CDATA[G-3145: Avoid using SELECT * directly from a table or view.]]></name>
		<internalKey>G-3145</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Use of SELECT * when querying a table or view makes it impossible for the
			optimizer to take into account which columns will actually be used by the
			application, potentially leading to sub-optimal execution plans (for example full
			scanning the table where a full scan of an index might have sufficed.) Also
			SELECT * possibly can break your code in the future in case of changes to the
			table structure (for example new or invisible columns.)</p>
			<p>Exceptions to the rule can be when querying an inline view (where the SELECT *
			is just to avoid repeating same columns as inside the inline view), or when
			fetching into records defined as MYTABLE%ROWTYPE for the purpose of processing
			all columns of the record.</p>
			<h2>Bad</h2>
<pre>begin
   &lt;&lt;raise_salary&gt;&gt;
   for r_employee in (
      select *
        from employees
   )
   loop
      employee_api.calculate_raise_by_seniority(
         id_in       =&gt; r_employee.id
        ,salary_in   =&gt; r_employee.salary
        ,hiredate_in =&gt; r_employee.hiredate
      );
   end loop raise_salary;
end;
/</pre>
			<h2>Good</h2>
<pre>begin
   &lt;&lt;raise_salary&gt;&gt;
   for r_employee in (
      select id,salary,hiredate
        from employees
   )
   loop
      employee_api.calculate_raise_by_seniority(
         id_in       =&gt; r_employee.id
        ,salary_in   =&gt; r_employee.salary
        ,hiredate_in =&gt; r_employee.hiredate
      );
   end loop raise_salary;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-3150</key>
		<name><![CDATA[G-3150: Try to use identity columns for surrogate keys.]]></name>
		<internalKey>G-3150</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Restriction</h2>
			<p>Oracle Database 12c</p>
			<h2>Reason</h2>
			<p>An identity column is a surrogate key by design – there is no reason why we should not take
			advantage of this natural implementation when the keys are generated on database level. Using
			identity column (and therefore assigning sequences as default values on columns) has a huge
			performance advantage over a trigger solution.</p>
			<h2>Bad</h2>
<pre>create table locations (
   location_id   number(10)        not null
  ,location_name varchar2(60 char) not null
  ,city          varchar2(30 char) not null
  ,constraint locations_pk primary key (location_id)
);

create sequence location_seq start with 1 cache 20;

create or replace trigger location_br_i
before insert on locations
for each row
begin
   :new.location_id := location_seq.nextval;
end;
/</pre>
			<h2>Good</h2>
<pre>-- GENERATED ALWAYS AS IDENTITY ensures that the location_id is populated by a sequence. 
-- It is not possible to override the behavior in the application. However, if you use a 
-- framework that produces an INSERT statement including the surrogate key column, 
-- and you cannot change this behavior, then you have to use the 
-- GENERATED BY DEFAULT ON NULL AS IDENTITY option. 
-- This has the downside that the application may pass a value, which might lead to an
-- immediate or delayed ORA-00001: unique constraint violated error.
create table locations (
   location_id   number(10) generated always as identity
  ,location_name varchar2(60 char) not null
  ,city          varchar2(30 char) not null
  ,constraint locations_pk primary key (location_id)
);</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-3160</key>
		<name><![CDATA[G-3160: Avoid visible virtual columns. (not implemented)]]></name>
		<internalKey>G-3160</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Restriction</h2>
			<p>Oracle Database 12c</p>
			<h2>Reason</h2>
			<p>In contrast to visible columns, invisible columns are not part of a record defined using <code>%rowtype</code>
			construct. This is helpful as a virtual column may not be programmatically populated. If your
			virtual column is visible you have to manually define the record types used in API packages to be
			able to exclude them from being part of the record definition.</p>
			<p>Invisible columns may be accessed by explicitly adding them to the column list in a <code>select</code>
			statement.</p>
			<h2>Bad</h2>
<pre>alter table employees
   add total_salary generated always as (salary + nvl(commission_pct,0) * salary)
/

declare
   r_employee employees%rowtype;
   l_id       employees.employee_id%type := 107;
begin
   r_employee        := employee_api.employee_by_id(l_id);
   r_employee.salary := r_employee.salary * constants_up.small_increase();

   update employees
      set row = r_employee
    where employee_id = l_id;
end;
/

/*
Error report -
ORA-54017: update operation disallowed on virtual columns
ORA-06512: at line 9
*/</pre>
			<h2>Good</h2>
<pre>alter table employees
   add total_salary invisible generated always as
      (salary + nvl(commission_pct,0) * salary)
/

declare
   r_employee employees%rowtype;
   co_id      constant employees.employee_id%type := 107;
begin
   r_employee        := employee_api.employee_by_id(co_id);
   r_employee.salary := r_employee.salary * constants_up.small_increase();

   update employees
      set row = r_employee
    where employee_id = co_id;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-3170</key>
		<name><![CDATA[G-3170: Always use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values. (not implemented)]]></name>
		<internalKey>G-3170</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Restriction</h2>
			<p>Oracle Database 12c</p>
			<h2>Reason</h2>
			<p>Default values have been nullifiable until Oracle Database 12c. Meaning any tool sending null as a value
			for a column having a default value bypassed the default value. Starting with Oracle Database 12c default
			definitions may have an <code>on null</code> definition in addition, which will assign the default value in
			case of a <code>null</code> value too.
			
			</p>
			<h2>Bad</h2>
<pre>create table null_test (
   test_case        number(2) not null
  ,column_defaulted varchar2(10 char) default 'Default')
/
insert into null_test(test_case,column_defaulted) values (1,'Value');
insert into null_test(test_case,column_defaulted) values (2,default);
insert into null_test(test_case,column_defaulted) values (3,null);

select * from null_test;

/*
TEST_CASE  COLUMN_DEF
---------  -----------
        1  Value
        2  Default
        3
*/</pre>
			<h2>Good</h2>
<pre>create table null_test (
   test_case        number(2) not null
  ,column_defaulted varchar2(10 char) default on null 'Default')
/
insert into null_test(test_case,column_defaulted) values (1,'Value');
insert into null_test(test_case,column_defaulted) values (2,default);
insert into null_test(test_case,column_defaulted) values (3,null);

select * from null_test;

/*
TEST_CASE  COLUMN_DEF
---------  ----------
        1  Value     
        2  Default   
        3  Default
*/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-3180</key>
		<name><![CDATA[G-3180: Always specify column names instead of positional references in ORDER BY clauses.]]></name>
		<internalKey>G-3180</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>If you change your <code>select</code> list afterwards the <code>order by</code> will still work but order your rows
			differently, when not changing the positional number. Furthermore, it is not comfortable to the
			readers of the code, if they have to count the columns in the <code>select</code> list to know the way the
			result is ordered.</p>
			<h2>Bad</h2>
<pre>select upper(first_name)
      ,last_name
      ,salary
      ,hire_date
  from employees
 order by 4,1,3;</pre>
			<h2>Good</h2>
<pre>select upper(first_name) as first_name
      ,last_name
      ,salary
      ,hire_date
  from employees
 order by hire_date
      ,first_name
      ,salary;</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-3185</key>
		<name><![CDATA[G-3185: Never use ROWNUM at the same query level as ORDER BY.]]></name>
		<internalKey>G-3185</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The <code>rownum</code> pseudo-column is assigned before the <code>order by</code> clause is used, so using rownum
			on the same query level as <code>order by</code> will not assign numbers in the desired ordering. Instead
			you should move the <code>order by</code> into an inline view and use <code>rownum</code> in the outer query.
			
			</p>
			<h2>Bad</h2>
<pre>select first_name
      ,last_name
      ,salary
      ,hire_date
      ,rownum as salary_rank
  from employees
 where rownum &lt;= 5
 order by salary desc;</pre>
			<h2>Good</h2>
<pre>select first_name
      ,last_name
      ,salary
      ,hire_date
      ,rownum as salary_rank
  from (
          select first_name
                ,last_name
                ,salary
                ,hire_date
            from employees
           order by salary desc
       )
 where rownum &lt;= 5;</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-3190</key>
		<name><![CDATA[G-3190: Avoid using NATURAL JOIN.]]></name>
		<internalKey>G-3190</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>A <code>natural join</code> joins tables on equally named columns. This may comfortably fit on first sight,
			but adding logging columns to a table (<code>changed_by</code>, <code>changed_date</code>) will result in inappropriate
			join conditions.</p>
			<h2>Bad</h2>
<pre>select d.department_name
      ,e.last_name
      ,e.first_name
  from employees e
natural join departments d
 order by d.department_name
      ,e.last_name;

/*
DEPARTMENT_NAME                LAST_NAME                 FIRST_NAME         
------------------------------ ------------------------- --------------------
Accounting                     Gietz                     William             
Executive                      De Haan                   Lex                 
...
*/

alter table departments add modified_at date default on null sysdate;
alter table employees add modified_at date default on null sysdate;

select d.department_name
      ,e.last_name
      ,e.first_name
  from employees e
natural join departments d
 order by d.department_name
      ,e.last_name;

/*
No data found
*/</pre>
			<h2>Good</h2>
<pre>select d.department_name
      ,e.last_name
      ,e.first_name
  from employees e
  join departments d
    on (e.department_id = d.department_id)
 order by d.department_name
      ,e.last_name;

/*
DEPARTMENT_NAME                LAST_NAME                 FIRST_NAME         
------------------------------ ------------------------- --------------------
Accounting                     Gietz                     William             
Executive                      De Haan                   Lex                 
...
*/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-3195</key>
		<name><![CDATA[G-3195: Always use wildcards in a LIKE clause.]]></name>
		<internalKey>G-3195</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Using <code>like</code> without at least one wildcard (<code>%</code> or <code>_</code>) is unclear to a maintainer whether a wildcard
			is forgotten or it is meant as equality test. A common antipattern is also to forget that an
			underscore is a wildcard, so using <code>like</code> instead of equal can return unwanted rows. If the <code>char</code>
			datatype is involved, there is also the danger of <code>like</code> not using blank padded comparison where
			equal will. Depending on use case, you should either remember at least one wildcard or use
			normal equality operator.</p>
			<h2>Bad</h2>
<pre>select e.employee_id
      ,e.last_name
  from employees e
 where e.last_name like 'Smith';</pre>
			<h2>Good</h2>
<pre>-- Using a wildcard:
select e.employee_id
      ,e.last_name
  from employees e
 where e.last_name like 'Smith%';

-- Change to equality operator instead:
select e.employee_id
      ,e.last_name
  from employees e
 where e.last_name = 'Smith';</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-3210</key>
		<name><![CDATA[G-3210: Always use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement for more than 4 times.]]></name>
		<internalKey>G-3210</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Context switches between PL/SQL and SQL are extremely costly. BULK Operations reduce the
			number of switches by passing an array to the SQL engine, which is used to execute the given
			statements repeatedly.</p>
			<p>(Depending on the PLSQL_OPTIMIZE_LEVEL parameter a conversion to BULK COLLECT will be
			done by the PL/SQL compiler automatically.)</p>
			<h2>Bad</h2>
<pre>declare
   t_employee_ids   employee_api.t_employee_ids_type;
   co_increase      constant employees.salary%type          := 0.1;
   co_department_id constant departments.department_id%type := 10;
begin
   t_employee_ids := employee_api.employee_ids_by_department(
                        id_in =&gt; co_department_id
                     );
   &lt;&lt;process_employees&gt;&gt;
   for i in 1..t_employee_ids.count()
   loop
      update employees
         set salary = salary + (salary * co_increase)
       where employee_id = t_employee_ids(i);
   end loop process_employees;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   t_employee_ids   employee_api.t_employee_ids_type;
   co_increase      constant employees.salary%type          := 0.1;
   co_department_id constant departments.department_id%type := 10;
begin
   t_employee_ids := employee_api.employee_ids_by_department(
                        id_in =&gt; co_department_id
                     );
   &lt;&lt;process_employees&gt;&gt;
   forall i in 1..t_employee_ids.count()
      update employees
         set salary = salary + (salary * co_increase)
       where employee_id = t_employee_ids(i);
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-3220</key>
		<name><![CDATA[G-3220: Always process saved exceptions from a FORALL statement.]]></name>
		<internalKey>G-3220</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Using save exceptions in a forall statement without actually processing the saved exceptions is just
			wasted work.</p>
			<p>If your use of forall is meant to be atomic (all or nothing), don't use save exceptions. If you want
			to handle errors of individual rows and do use save exceptions, always include an exception handler
			block with a loop to process the saved exceptions.</p>
			<h2>Bad</h2>
<pre>declare
   t_employee_ids   employee_api.t_employee_ids_type;
   co_increase      constant employees.salary%type          := 0.1;
   co_department_id constant departments.department_id%type := 10;
   e_bulk_errors    exception;
   pragma exception_init(e_bulk_errors,-24381);
begin
   t_employee_ids := employee_api.employee_ids_by_department(
                        id_in =&gt; co_department_id
                     );
   &lt;&lt;process_employees&gt;&gt;
   forall i in 1..t_employee_ids.count() save exceptions
      update employees
         set salary = salary + (salary * co_increase)
       where employee_id = t_employee_ids(i);
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   t_employee_ids   employee_api.t_employee_ids_type;
   co_increase      constant employees.salary%type          := 0.1;
   co_department_id constant departments.department_id%type := 10;
   e_bulk_errors    exception;
   pragma exception_init(e_bulk_errors,-24381);
begin
   t_employee_ids := employee_api.employee_ids_by_department(
                        id_in =&gt; co_department_id
                     );
   &lt;&lt;process_employees&gt;&gt;
   forall i in 1..t_employee_ids.count() save exceptions
      update employees
         set salary = salary + (salary * co_increase)
       where employee_id = t_employee_ids(i);
exception
   when e_bulk_errors then
      &lt;&lt;handle_bulk_exceptions&gt;&gt;
      for i in 1..sql%bulk_exceptions.count
      loop
         logger.log(sql%bulk_exceptions(i).error_code);
      end loop handle_bulk_exceptions;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-3310</key>
		<name><![CDATA[G-3310: Never commit within a cursor loop.]]></name>
		<internalKey>G-3310</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Doing frequent commits within a cursor loop (all types of loops over cursors, whether implicit
			cursor for loop or loop with explicit fetch from cursor or cursor variable) risks not being able to
			complete due to ORA-01555, gives bad performance, and risks that the work is left in an 
			unknown half-finished state and cannot be restarted.</p>
			<ul>
			<li>If the work belongs together (an atomic transaction) the commit should be moved to after 
			the loop. Or even better if the logic can be rewritten to a single DML statement on all relevant
			rows instead of a loop, committing after the single statement.</li>
			<li>If each loop iteration is a self-contained atomic transaction, consider instead to populate a
			collection of transactions to be done (taking restartability into account by collection
			population), loop over that collection (instead of looping over a cursor) and call a procedure
			(that contains the transaction logic and the commit) in the loop (see also G-3320).</li>
			</ul>
			<h2>Bad</h2>
<pre>declare
   l_counter  integer := 0;
   l_discount discount.percentage%type;
begin
   &lt;&lt;new_orders&gt;&gt;
   for r_order in (
      select o.order_id,o.customer_id
        from orders o
       where o.order_status = 'New'
   )
   loop
      l_discount := sales_api.calculate_discount(p_customer_id =&gt; r_order.customer_id);

      update order_lines ol
         set ol.discount = l_discount
       where ol.order_id = r_order.order_id;

      l_counter  := l_counter + 1;
      if l_counter = 100 then
         commit;
         l_counter := 0;
      end if;
   end loop new_orders;
   if l_counter &gt; 0 then
      commit;
   end if;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_discount discount.percentage%type;
begin
   &lt;&lt;new_orders&gt;&gt;
   for r_order in (
      select o.order_id,o.customer_id
        from orders o
       where o.order_status = 'New'
   )
   loop
      l_discount := sales_api.calculate_discount(p_customer_id =&gt; r_order.customer_id);

      update order_lines ol
         set ol.discount = l_discount
       where ol.order_id = r_order.order_id;
   end loop new_orders;

   commit;
end;
/</pre>
			<h2>Best</h2>
<pre>-- (Assuming suitable foreign key relationship exists to allow updating a join.)
begin
   update (
             select o.customer_id,ol.discount
               from orders o
               join order_lines ol
                 on ol.order_id = o.order_id
              where o.order_status = 'New'
          )
      set discount = sales_api.calculate_discount(p_customer_id =&gt; customer_id);

   commit;
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-3320</key>
		<name><![CDATA[G-3320: Try to move transactions within a non-cursor loop into procedures.]]></name>
		<internalKey>G-3320</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Commit inside a non-cursor loop (other loop types than loops over cursors - see also G-3310) is
			either a self-contained atomic transaction, or it is a chunk (with suitable restartability handling) of
			very large data manipulations. In either case encapsulating the transaction in a procedure is
			good modularity, enabling reuse and testing of a single call.</p>
			<h2>Bad</h2>
<pre>begin
   &lt;&lt;create_headers&gt;&gt;
   for l_counter in 1..5
   loop
      insert into headers (id,text) values (l_counter,'Number ' || l_counter);

      insert into lines (header_id,line_no,text)
      select l_counter,rownum,'Line ' || rownum
        from dual
     connect by level &lt;= 3;

      commit;
   end loop create_headers;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   procedure create_rows(
      p_header_id in headers.id%type
   ) is
   begin
      insert into headers (id,text) values (p_header_id,'Number ' || p_header_id);

      insert into lines (header_id,line_no,text)
      select p_header_id,rownum,'Line ' || rownum
        from dual
     connect by level &lt;= 3;

      commit;
   end;
begin
   &lt;&lt;create_headers&gt;&gt;
   for l_counter in 1..5
   loop
      create_rows(l_counter);
   end loop create_headers;
end;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-4110</key>
		<name><![CDATA[G-4110: Always use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data.]]></name>
		<internalKey>G-4110</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The readability of your code will be higher when you avoid negative sentences.</p>
			<h2>Bad</h2>
<pre>declare
   cursor c_employees is
      select last_name
            ,first_name
        from employees
       where commission_pct is not null;

   r_employee c_employees%rowtype;
begin
   open c_employees;

   &lt;&lt;read_employees&gt;&gt;
   loop
      fetch c_employees into r_employee;
      exit read_employees when not c_employees%found;
   end loop read_employees;

   close c_employees;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   cursor c_employees is
      select last_name
            ,first_name
        from employees
       where commission_pct is not null;

   r_employee c_employees%rowtype;
begin
   open c_employees;

   &lt;&lt;read_employees&gt;&gt;
   loop
      fetch c_employees into r_employee;
      exit read_employees when c_employees%notfound;
   end loop read_employees;

   close c_employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-4120</key>
		<name><![CDATA[G-4120: Avoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause.]]></name>
		<internalKey>G-4120</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p><code>%notfound</code> is set to <code>true</code> as soon as less than the number of rows defined by the <code>limit</code> clause
			has been read.</p>
			<h2>Bad</h2>
<pre>-- The employees table holds 107 rows. The example below will only show 100 rows as the cursor
-- attribute notfound is set to true as soon as the number of rows to be fetched defined by the
-- limit clause is not fulfilled anymore.
declare
   cursor c_employees is
      select *
        from employees
       order by employee_id;

   type t_employees_type is table of c_employees%rowtype;
   t_employees  t_employees_type;
   co_bulk_size constant simple_integer := 10;
begin
   open c_employees;

   &lt;&lt;process_employees&gt;&gt;
   loop
      fetch c_employees bulk collect into t_employees limit co_bulk_size;
      exit process_employees when c_employees%notfound;

      &lt;&lt;display_employees&gt;&gt;
      for i in 1..t_employees.count()
      loop
         sys.dbms_output.put_line(t_employees(i).last_name);
      end loop display_employees;
   end loop process_employees;

   close c_employees;
end;
/</pre>
			<h2>Better</h2>
<pre>-- This example will show all 107 rows but execute one fetch too much (12 instead of 11).
declare
   cursor c_employees is
      select *
        from employees
       order by employee_id;

   type t_employees_type is table of c_employees%rowtype;
   t_employees  t_employees_type;
   co_bulk_size constant simple_integer := 10;
begin
   open c_employees;

   &lt;&lt;process_employees&gt;&gt;
   loop
      fetch c_employees bulk collect into t_employees limit co_bulk_size;
      exit process_employees when t_employees.count() = 0;
      &lt;&lt;display_employees&gt;&gt;
      for i in 1..t_employees.count()
      loop
         sys.dbms_output.put_line(t_employees(i).last_name);
      end loop display_employees;
   end loop process_employees;

   close c_employees;
end;
/</pre>
			<h2>Good</h2>
<pre>-- This example does the trick (11 fetches only to all rows)
declare
   cursor c_employees is
      select *
        from employees
       order by employee_id;

   type t_employees_type is table of c_employees%rowtype;
   t_employees  t_employees_type;
   co_bulk_size constant simple_integer := 10;
begin
   open c_employees;

   &lt;&lt;process_employees&gt;&gt;
   loop
      fetch c_employees bulk collect into t_employees limit co_bulk_size;
      &lt;&lt;display_employees&gt;&gt;
      for i in 1..t_employees.count()
      loop
         sys.dbms_output.put_line(t_employees(i).last_name);
      end loop display_employees;
      exit process_employees when t_employees.count() &lt;&gt; co_bulk_size;
   end loop process_employees;

   close c_employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-4130</key>
		<name><![CDATA[G-4130: Always close locally opened cursors.]]></name>
		<internalKey>G-4130</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Any cursors left open can consume additional memory space (i.e. SGA) within the database
			instance, potentially in both the shared and private SQL pools. Furthermore, failure to explicitly
			close cursors may also cause the owning session to exceed its maximum limit of open cursors
			(as specified by the <code>open_cursors</code> database initialization parameter), potentially resulting in the
			Oracle Database error of “ORA-01000: maximum open cursors exceeded”.</p>
			<h2>Bad</h2>
<pre>create or replace package body employee_api as
   function department_salary(in_dept_id in departments.department_id%type)
      return number is
      cursor c_department_salary(p_dept_id in departments.department_id%type) is
         select sum(salary) as sum_salary
           from employees
          where department_id = p_dept_id;
      r_department_salary c_department_salary%rowtype;
   begin
      open c_department_salary(p_dept_id =&gt; in_dept_id);
      fetch c_department_salary into r_department_salary;

      return r_department_salary.sum_salary;
   end department_salary;
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api as
   function department_salary(in_dept_id in departments.department_id%type)
      return number is
      cursor c_department_salary(p_dept_id in departments.department_id%type) is
         select sum(salary) as sum_salary
           from employees
          where department_id = p_dept_id;
      r_department_salary c_department_salary%rowtype;
   begin
      open c_department_salary(p_dept_id =&gt; in_dept_id);
      fetch c_department_salary into r_department_salary;
      close c_department_salary;
      return r_department_salary.sum_salary;
   end department_salary;
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-4140</key>
		<name><![CDATA[G-4140: Avoid executing any statements between a SQL operation and the usage of an implicit cursor attribute.]]></name>
		<internalKey>G-4140</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The Oracle Database provides a variety of cursor attributes (like <code>%found</code> and <code>%rowcount</code>) that can be used to
			obtain information about the status of a cursor, either implicit or explicit.</p>
			<p>You should avoid inserting any statements between the cursor operation and the use of an
			attribute against that cursor. Interposing such a statement can affect the value returned by the
			attribute, thereby potentially corrupting the logic of your program.</p>
			<p>In the following example, a procedure call is inserted between the delete statement and a
			check for the value of <code>sql%rowcount</code>, which returns the number of rows modified by that last
			SQL statement executed in the session. If this procedure includes a <code>commit</code> / <code>rollback</code> or 
			another implicit cursor the value of <code>sql%rowcount</code> is affected.</p>
			<h2>Bad</h2>
<pre>create or replace package body employee_api as
   co_one constant simple_integer := 1;

   procedure process_dept(in_dept_id in departments.department_id%type) is
   begin
      null;
   end process_dept;

   procedure remove_employee(in_employee_id in employees.employee_id%type) is
      l_dept_id employees.department_id%type;
   begin
      delete from employees
       where employee_id = in_employee_id
   returning department_id into l_dept_id;

      process_dept(in_dept_id =&gt; l_dept_id);

      if sql%rowcount &gt; co_one then
         -- too many rows deleted. 
         rollback;
      end if;
   end remove_employee;
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api as
   co_one constant simple_integer := 1;

   procedure process_dept(in_dept_id in departments.department_id%type) is
   begin
      null;
   end process_dept;

   procedure remove_employee(in_employee_id in employees.employee_id%type) is
      l_dept_id      employees.department_id%type;
      l_deleted_emps simple_integer;
   begin
      delete from employees
       where employee_id = in_employee_id
   returning department_id into l_dept_id;

      l_deleted_emps := sql%rowcount;

      process_dept(in_dept_id =&gt; l_dept_id);

      if l_deleted_emps &gt; co_one then
         -- too many rows deleted. 
         rollback;
      end if;
   end remove_employee;
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-4210</key>
		<name><![CDATA[G-4210: Try to use CASE rather than an IF statement with multiple ELSIF paths.]]></name>
		<internalKey>G-4210</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p><code>if</code> statements containing multiple <code>elsif</code> tend to become complex quickly.</p>
			<h2>Bad</h2>
<pre>declare
   l_color types_up.color_code_type;
begin
   if l_color = constants_up.co_red then
      my_package.do_red();
   elsif l_color = constants_up.co_blue then
      my_package.do_blue();
   elsif l_color = constants_up.co_black then
      my_package.do_black();
   end if;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_color types_up.color_code_type;
begin
   case l_color
      when constants_up.co_red then
         my_package.do_red();
      when constants_up.co_blue then
         my_package.do_blue();
      when constants_up.co_black then
         my_package.do_black();
      else
         null;
   end case;
end;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-4220</key>
		<name><![CDATA[G-4220: Try to use CASE rather than DECODE.]]></name>
		<internalKey>G-4220</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p><code>decode</code> is an Oracle Database specific function hard to understand and restricted to SQL only. The 
			“newer” <code>case</code> function is much more common, has a better readability and may be used within
			PL/SQL too. Be careful that <code>decode</code> can handle <code>null</code> values, which the simple <code>case</code> cannot - for
			such cases you must use the searched <code>case</code> and <code>is null</code> instead.</p>
			<h2>Bad</h2>
<pre>-- @formatter:off
select decode(ctry.country_code, constants_up.co_ctry_uk, constants_up.co_lang_english 
                               , constants_up.co_ctry_fr, constants_up.co_lang_french
                               , constants_up.co_ctry_de, constants_up.co_lang_german
                                                        , constants_up.co_lang_not_supported)
  from countries ctry;

-- null values can be compared in decode:
select decode(ctry.country_code, constants_up.co_ctry_uk, constants_up.co_lang_english 
                               , constants_up.co_ctry_fr, constants_up.co_lang_french
                               , null                   , constants_up.co_lang_unknown
                                                        , constants_up.co_lang_not_supported)
  from countries ctry;</pre>
			<h2>Good</h2>
<pre>-- @formatter:on
select case ctry.country_code
          when constants_up.co_ctry_uk then
             constants_up.co_lang_english
          when constants_up.co_ctry_fr then
             constants_up.co_lang_french
          when constants_up.co_ctry_de then
             constants_up.co_lang_german
          else
             constants_up.co_lang_not_supported
       end
  from countries ctry;

-- Simple case can not compare null values, instead the searched case expression must be used:
select case
          when ctry.country_code = constants_up.co_ctry_uk then
             constants_up.co_lang_english
          when ctry.country_code = constants_up.co_ctry_fr then
             constants_up.co_lang_french
          when ctry.country_code is null then
             constants_up.co_lang_unknown
          else
             constants_up.co_lang_not_supported
       end
  from countries ctry;</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-4230</key>
		<name><![CDATA[G-4230: Always use a COALESCE instead of a NVL command, if parameter 2 of the NVL function is a function call or a SELECT statement.]]></name>
		<internalKey>G-4230</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The nvl function always evaluates both parameters before deciding which one to use. This can
			be harmful if parameter 2 is either a function call or a select statement, as it will be executed
			regardless of whether parameter 1 contains a null value or not.</p>
			<p>The coalesce function does not have this drawback.</p>
			<h2>Bad</h2>
<pre>select nvl(dummy,my_package.expensive_null(value_in =&gt; dummy))
  from dual;</pre>
			<h2>Good</h2>
<pre>select coalesce(dummy,my_package.expensive_null(value_in =&gt; dummy))
  from dual;</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-4240</key>
		<name><![CDATA[G-4240: Always use a CASE instead of a NVL2 command if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement.]]></name>
		<internalKey>G-4240</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The nvl2 function always evaluates all parameters before deciding which one to use. This can
			be harmful, if parameter 2 or 3 is either a function call or a select statement, as they will be
			executed regardless of whether parameter 1 contains a null value or not.</p>
			<h2>Bad</h2>
<pre>select nvl2(dummy,my_package.expensive_nn(value_in =&gt; dummy)
         ,my_package.expensive_null(value_in =&gt; dummy))
  from dual;</pre>
			<h2>Good</h2>
<pre>select case
          when dummy is null then
             my_package.expensive_null(value_in =&gt; dummy)
          else
             my_package.expensive_nn(value_in =&gt; dummy)
       end
  from dual;</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-4250</key>
		<name><![CDATA[G-4250: Avoid using identical conditions in different branches of the same IF or CASE statement.]]></name>
		<internalKey>G-4250</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Conditions are evaluated top to bottom in branches of a case statement or chain of <code>if</code>/<code>elsif</code>
			statements. The first condition to evaluate as true leads to that branch being executed, the rest
			will never execute. Having an identical duplicated condition in another branch will never be
			reached and will be dead code.</p>
			<h2>Bad</h2>
<pre>declare
   l_color types_up.color_code_type;
begin
   case l_color
      when constants_up.co_red then
         my_package.do_red();
      when constants_up.co_blue then
         my_package.do_blue();
      when constants_up.co_red then  -- never reached
         my_package.do_black();      -- dead code
      else
         null;
   end case;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_color types_up.color_code_type;
begin
   case l_color
      when constants_up.co_red then
         my_package.do_red();
      when constants_up.co_blue then
         my_package.do_blue();
      when constants_up.co_black then
         my_package.do_black();
      else
         null;
   end case;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-4260</key>
		<name><![CDATA[G-4260: Avoid inverting boolean conditions with NOT.]]></name>
		<internalKey>G-4260</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>It is more readable to use the opposite comparison operator instead of inverting the comparison
			with <code>not</code>.</p>
			<h2>Bad</h2>
<pre>declare
   l_color varchar2(7 char);
begin
   if not l_color != constants_up.co_red then
      my_package.do_red();
   end if;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_color types_up.color_code_type;
begin
   if l_color = constants_up.co_red then
      my_package.do_red();
   end if;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-4270</key>
		<name><![CDATA[G-4270: Avoid comparing boolean values to boolean literals.]]></name>
		<internalKey>G-4270</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>It is more readable to simply use the boolean value as a condition itself, rather than use a
			comparison condition comparing the boolean value to the literals <code>true</code> or <code>false</code>.</p>
			<h2>Bad</h2>
<pre>declare
   l_string   varchar2(10 char) := '42';
   l_is_valid boolean;
begin
   l_is_valid := my_package.is_valid_number(l_string);
   if l_is_valid = true then
      my_package.convert_number(l_string);
   end if;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_string   varchar2(10 char) := '42';
   l_is_valid boolean;
begin
   l_is_valid := my_package.is_valid_number(l_string);
   if l_is_valid then
      my_package.convert_number(l_string);
   end if;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-4310</key>
		<name><![CDATA[G-4310: Never use GOTO statements in your code.]]></name>
		<internalKey>G-4310</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Code containing gotos is hard to format. Indentation should be used to 
			show logical structure and gotos have an effect on logical structure. 
			Trying to use indentation to show the logical structure of a goto, 
			however, is difficult or impossible.</p>
			<p>Use of gotos is a matter of religion. In modern languages, you can easily
			replace nine out of ten gotos with equivalent structured constructs. 
			In these simple cases, you should replace gotos out of habit. In the hard cases, 
			you can break the code into smaller routines; use nested ifs; test and retest 
			a status variable; or restructure a conditional. Eliminating the goto is harder 
			in these cases, but it's good mental exercise.</p>
			<p>Excerpt of http://www.stevemcconnell.com/ccgoto.htm</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   procedure password_check(in_password in varchar2) is
      co_digitarray  constant string(10 char)  := '0123456789';
      co_lower_bound constant simple_integer   := 1;
      co_errno       constant simple_integer   := -20501;
      co_errmsg      constant string(100 char) := 'Password must contain a digit.';
      l_isdigit      boolean                   := false;
      l_len_pw       pls_integer;
      l_len_array    pls_integer;
   begin
      l_len_pw    := length(in_password);
      l_len_array := length(co_digitarray);

      &lt;&lt;check_digit&gt;&gt;
      for i in co_lower_bound..l_len_array
      loop
         &lt;&lt;check_pw_char&gt;&gt;
         for j in co_lower_bound..l_len_pw
         loop
            if substr(in_password,j,1) = substr(co_digitarray,i,1) then
               l_isdigit := true;
               goto check_other_things;
            end if;
         end loop check_pw_char;
      end loop check_digit;

      &lt;&lt;check_other_things&gt;&gt;
      null;

      if not l_isdigit then
         raise_application_error(co_errno,co_errmsg);
      end if;
   end password_check;
end my_package;
/</pre>
			<h2>Better</h2>
<pre>create or replace package body my_package is
   procedure password_check(in_password in varchar2) is
      co_digitarray  constant string(10 char)  := '0123456789';
      co_lower_bound constant simple_integer   := 1;
      co_errno       constant simple_integer   := -20501;
      co_errmsg      constant string(100 char) := 'Password must contain a digit.';
      l_isdigit      boolean                   := false;
      l_len_pw       pls_integer;
      l_len_array    pls_integer;
   begin
      l_len_pw    := length(in_password);
      l_len_array := length(co_digitarray);

      &lt;&lt;check_digit&gt;&gt;
      for i in co_lower_bound..l_len_array
      loop
         &lt;&lt;check_pw_char&gt;&gt;
         for j in co_lower_bound..l_len_pw
         loop
            if substr(in_password,j,1) = substr(co_digitarray,i,1) then
               l_isdigit := true;
               exit check_digit; -- early exit condition
            end if;
         end loop check_pw_char;
      end loop check_digit;

      &lt;&lt;check_other_things&gt;&gt;
      null;

      if not l_isdigit then
         raise_application_error(co_errno,co_errmsg);
      end if;
   end password_check;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   procedure password_check(in_password in varchar2) is
      co_digitpattern constant string(10 char)  := '\d';
      co_errno        constant simple_integer   := -20501;
      co_errmsg       constant string(100 char) := 'Password must contain a digit.';
   begin
      if not regexp_like(in_password,co_digitpattern) then
         raise_application_error(co_errno,co_errmsg);
      end if;
   end password_check;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-4320</key>
		<name><![CDATA[G-4320: Always label your loops.]]></name>
		<internalKey>G-4320</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>It's a good alternative for comments to indicate the start and end of a named loop processing.</p>
			<h2>Bad</h2>
<pre>declare
   i            integer;
   co_min_value constant simple_integer := 1;
   co_max_value constant simple_integer := 10;
   co_increment constant simple_integer := 1;
begin
   i := co_min_value;
   while (i &lt;= co_max_value)
   loop
      i := i + co_increment;
   end loop;

   loop
      exit;
   end loop;

   for i in co_min_value..co_max_value
   loop
      sys.dbms_output.put_line(i);
   end loop;

   for r_employee in (select last_name from employees)
   loop
      sys.dbms_output.put_line(r_employee.last_name);
   end loop;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   i            integer;
   co_min_value constant simple_integer := 1;
   co_max_value constant simple_integer := 10;
   co_increment constant simple_integer := 1;
begin
   i := co_min_value;
   &lt;&lt;while_loop&gt;&gt;
   while (i &lt;= co_max_value)
   loop
      i := i + co_increment;
   end loop while_loop;

   &lt;&lt;basic_loop&gt;&gt;
   loop
      exit basic_loop;
   end loop basic_loop;

   &lt;&lt;for_loop&gt;&gt;
   for i in co_min_value..co_max_value
   loop
      sys.dbms_output.put_line(i);
   end loop for_loop;

   &lt;&lt;process_employees&gt;&gt;
   for r_employee in (
      select last_name
        from employees
   )
   loop
      sys.dbms_output.put_line(r_employee.last_name);
   end loop process_employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-4325</key>
		<name><![CDATA[G-4325: Never reuse labels in inner scopes.]]></name>
		<internalKey>G-4325</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Reusing labels inside the scope of another label with the same name leads to confusion, less
			chance of understanding the code, and could lead to bugs (for example if using exit <code>my_label</code>
			exits at a different nesting level than expected.)</p>
			<h2>Bad</h2>
<pre>&lt;&lt;my_label&gt;&gt;
declare
   co_min_value constant simple_integer := 1;
   co_max_value constant simple_integer := 8;
begin
   &lt;&lt;my_label&gt;&gt;
   for i in co_min_value..co_max_value
   loop
      sys.dbms_output.put_line(i);
   end loop my_label;
end my_label;
/</pre>
			<h2>Good</h2>
<pre>&lt;&lt;output_values&gt;&gt;
declare
   co_min_value constant simple_integer := 1;
   co_max_value constant simple_integer := 8;
begin
   &lt;&lt;process_values&gt;&gt;
   for i in co_min_value..co_max_value
   loop
      sys.dbms_output.put_line(i);
   end loop process_values;
end output_values;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-4330</key>
		<name><![CDATA[G-4330: Always use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations.]]></name>
		<internalKey>G-4330</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>It is easier for the reader to see, that the complete data set is processed. Using SQL to define the
			data to be processed is easier to maintain and typically faster than using conditional processing
			within the loop.</p>
			<p>Since an <code>exit</code> statement is similar to a <code>goto</code> statement, it should be avoided, whenever
			possible.</p>
			<h2>Bad</h2>
<pre>declare
   cursor c_employees is
      select employee_id,last_name
        from employees;
   r_employee c_employees%rowtype;
begin
   open c_employees;

   &lt;&lt;read_employees&gt;&gt;
   loop
      fetch c_employees into r_employee;
      exit read_employees when c_employees%notfound;
      sys.dbms_output.put_line(r_employee.last_name);
   end loop read_employees;

   close c_employees;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   cursor c_employees is
      select employee_id,last_name
        from employees;
begin
   &lt;&lt;read_employees&gt;&gt;
   for r_employee in c_employees
   loop
      sys.dbms_output.put_line(r_employee.last_name);
   end loop read_employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-4340</key>
		<name><![CDATA[G-4340: Always use a NUMERIC FOR loop to process a dense array.]]></name>
		<internalKey>G-4340</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>It is easier for the reader to see, that the complete array is processed.</p>
			<p>Since an <code>exit</code> statement is similar to a <code>goto</code> statement, it should be avoided, whenever
			possible.</p>
			<h2>Bad</h2>
<pre>declare
   type t_employee_type is varray(10) of employees.employee_id%type;
   t_employees   t_employee_type;
   co_himuro     constant integer        := 118;
   co_livingston constant integer        := 177;
   co_min_value  constant simple_integer := 1;
   co_increment  constant simple_integer := 1;
   i             pls_integer;
begin
   t_employees := t_employee_type(co_himuro,co_livingston);
   i           := co_min_value;

   &lt;&lt;process_employees&gt;&gt;
   loop
      exit process_employees when i &gt; t_employees.count();
      sys.dbms_output.put_line(t_employees(i));
      i := i + co_increment;
   end loop process_employees;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   type t_employee_type is varray(10) of employees.employee_id%type;
   t_employees   t_employee_type;
   co_himuro     constant integer := 118;
   co_livingston constant integer := 177;
begin
   t_employees := t_employee_type(co_himuro,co_livingston);

   &lt;&lt;process_employees&gt;&gt;
   for i in 1..t_employees.count()
   loop
      sys.dbms_output.put_line(t_employees(i));
   end loop process_employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-4350</key>
		<name><![CDATA[G-4350: Always use 1 as lower and COUNT() as upper bound when looping through a dense array.]]></name>
		<internalKey>G-4350</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Doing so will not raise a <code>value_error</code> if the array you are looping through is empty. If you want
			to use <code>first()..last()</code> you need to check the array for emptiness beforehand to avoid the
			raise of <code>value_error</code>.</p>
			<h2>Bad</h2>
<pre>declare
   type t_employee_type is table of employees.employee_id%type;
   t_employees t_employee_type := t_employee_type();
begin
   &lt;&lt;process_employees&gt;&gt;
   for i in t_employees.first()..t_employees.last()
   loop
      sys.dbms_output.put_line(t_employees(i)); -- some processing
   end loop process_employees;
end;
/</pre>
			<h2>Better</h2>
<pre>-- Raise an unitialized collection error if t_employees is not initialized.
declare
   type t_employee_type is table of employees.employee_id%type;
   t_employees t_employee_type := t_employee_type();
begin
   &lt;&lt;process_employees&gt;&gt;
   for i in 1..t_employees.count()
   loop
      sys.dbms_output.put_line(t_employees(i)); -- some processing
   end loop process_employees;
end;
/</pre>
			<h2>Good</h2>
<pre>-- Raises neither an error nor checking whether the array is empty. t_employees.count() always
-- returns a number (unless the array is not initialized). If the array is empty count() returns 0 and
-- therefore the loop will not be entered.
declare
   type t_employee_type is table of employees.employee_id%type;
   t_employees t_employee_type := t_employee_type();
begin
   if t_employees is not null then
      &lt;&lt;process_employees&gt;&gt;
      for i in 1..t_employees.count()
      loop
         sys.dbms_output.put_line(t_employees(i)); -- some processing
      end loop process_employees;
   end if;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-4360</key>
		<name><![CDATA[G-4360: Always use a WHILE loop to process a loose array.]]></name>
		<internalKey>G-4360</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>When a loose (also called sparse) array is processed using a numeric <code>for loop</code> we have to
			check with all iterations whether the element exist to avoid a <code>no_data_found</code> exception. In
			addition, the number of iterations is not driven by the number of elements in the array but by
			the number of the lowest/highest element. The more gaps we have, the more superfluous iterations
			will be done.</p>
			<h2>Bad</h2>
<pre>declare -- raises no_data_found when processing 2nd record
   type t_employee_type is table of employees.employee_id%type;
   t_employees    t_employee_type;
   co_rogers      constant integer := 134;
   co_matos       constant integer := 143;
   co_mcewen      constant integer := 158;
   co_index_matos constant integer := 2;
begin
   t_employees := t_employee_type(co_rogers,co_matos,co_mcewen);
   t_employees.delete(co_index_matos);

   if t_employees is not null then
      &lt;&lt;process_employees&gt;&gt;
      for i in 1..t_employees.count()
      loop
         sys.dbms_output.put_line(t_employees(i));
      end loop process_employees;
   end if;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   type t_employee_type is table of employees.employee_id%type;
   t_employees    t_employee_type;
   co_rogers      constant integer := 134;
   co_matos       constant integer := 143;
   co_mcewen      constant integer := 158;
   co_index_matos constant integer := 2;
   l_index        pls_integer;
begin
   t_employees := t_employee_type(co_rogers,co_matos,co_mcewen);
   t_employees.delete(co_index_matos);

   l_index     := t_employees.first();

   &lt;&lt;process_employees&gt;&gt;
   while l_index is not null
   loop
      sys.dbms_output.put_line(t_employees(l_index));
      l_index := t_employees.next(l_index);
   end loop process_employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-4365</key>
		<name><![CDATA[G-4365: Never use unconditional CONTINUE or EXIT in a loop.]]></name>
		<internalKey>G-4365</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>An unconditional continue is either redundant (a continue as the last statement before the end of the
			loop) or causes dead code. An unconditional exit causes no looping and may cause dead code as well. If
			continue or exit is needed, it should always have a condition.</p>
			<h2>Bad</h2>
<pre>begin
   &lt;&lt;process_employees&gt;&gt;
   loop
      my_package.some_processing();
      continue process_employees;
      my_package.some_further_processing(); -- Dead code
   end loop process_employees;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   co_first_year constant pls_integer := 1900;
begin
   &lt;&lt;process_employees&gt;&gt;
   loop
      my_package.some_processing();
      continue process_employees when extract(year from sysdate) &gt; co_first_year;
      my_package.some_further_processing();
   end loop process_employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-4370</key>
		<name><![CDATA[G-4370: Avoid using EXIT to stop loop processing unless you are in a basic loop.]]></name>
		<internalKey>G-4370</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>A numeric for loop as well as a while loop and a cursor for loop have defined loop boundaries. If
			you are not able to exit your loop using those loop boundaries, then a basic loop is the right loop
			to choose.</p>
			<h2>Bad</h2>
<pre>declare
   i            integer;
   co_min_value constant simple_integer := 1;
   co_max_value constant simple_integer := 10;
   co_increment constant simple_integer := 1;
begin
   i := co_min_value;
   &lt;&lt;while_loop&gt;&gt;
   while (i &lt;= co_max_value)
   loop
      i := i + co_increment;
      exit while_loop when i &gt; co_max_value;
   end loop while_loop;

   &lt;&lt;basic_loop&gt;&gt;
   loop
      exit basic_loop;
   end loop basic_loop;

   &lt;&lt;for_loop&gt;&gt;
   for i in co_min_value..co_max_value
   loop
      null;
      exit for_loop when i = co_max_value;
   end loop for_loop;

   &lt;&lt;process_employees&gt;&gt;
   for r_employee in (
      select last_name
        from employees
   )
   loop
      sys.dbms_output.put_line(r_employee.last_name);
      null; -- some processing
      exit process_employees;
   end loop process_employees;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   i            integer;
   co_min_value constant simple_integer := 1;
   co_max_value constant simple_integer := 10;
   co_increment constant simple_integer := 1;
begin
   i := co_min_value;
   &lt;&lt;while_loop&gt;&gt;
   while (i &lt;= co_max_value)
   loop
      i := i + co_increment;
   end loop while_loop;

   &lt;&lt;basic_loop&gt;&gt;
   loop
      exit basic_loop;
   end loop basic_loop;

   &lt;&lt;for_loop&gt;&gt;
   for i in co_min_value..co_max_value
   loop
      sys.dbms_output.put_line(i);
   end loop for_loop;

   &lt;&lt;process_employees&gt;&gt;
   for r_employee in (
      select last_name
        from employees
   )
   loop
      sys.dbms_output.put_line(r_employee.last_name); -- some processing
   end loop process_employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-4375</key>
		<name><![CDATA[G-4375: Always use EXIT WHEN instead of an IF statement to exit from a loop.]]></name>
		<internalKey>G-4375</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>If you need to use an <code>exit</code> statement use its full semantic to make the code easier to
			understand and maintain. There is simply no need for an additional <code>if</code> statement.</p>
			<h2>Bad</h2>
<pre>declare
   co_first_year constant pls_integer := 1900;
begin
   &lt;&lt;process_employees&gt;&gt;
   loop
      my_package.some_processing();

      if extract(year from sysdate) &gt; co_first_year then
         exit process_employees;
      end if;

      my_package.some_further_processing();
   end loop process_employees;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   co_first_year constant pls_integer := 1900;
begin
   &lt;&lt;process_employees&gt;&gt;
   loop
      my_package.some_processing();

      exit process_employees when extract(year from sysdate) &gt; co_first_year;

      my_package.some_further_processing();
   end loop process_employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-4380</key>
		<name><![CDATA[G-4380: Try to label your EXIT WHEN statements.]]></name>
		<internalKey>G-4380</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>It's a good alternative for comments, especially for nested loops to name the loop to exit.</p>
			<h2>Bad</h2>
<pre>declare
   co_init_loop  constant simple_integer           := 0;
   co_increment  constant simple_integer           := 1;
   co_exit_value constant simple_integer           := 3;
   co_outer_text constant types_up.short_text_type := 'Outer Loop counter is ';
   co_inner_text constant types_up.short_text_type := ' Inner Loop counter is ';
   l_outerlp     pls_integer;
   l_innerlp     pls_integer;
begin
   l_outerlp := co_init_loop;
   &lt;&lt;outerloop&gt;&gt;
   loop
      l_innerlp := co_init_loop;
      l_outerlp := nvl(l_outerlp,co_init_loop) + co_increment;
      &lt;&lt;innerloop&gt;&gt;
      loop
         l_innerlp := nvl(l_innerlp,co_init_loop) + co_increment;
         sys.dbms_output.put_line(co_outer_text
            || l_outerlp
            || co_inner_text
            || l_innerlp);

         exit when l_innerlp = co_exit_value;
      end loop innerloop;

      exit when l_innerlp = co_exit_value;
   end loop outerloop;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   co_init_loop  constant simple_integer           := 0;
   co_increment  constant simple_integer           := 1;
   co_exit_value constant simple_integer           := 3;
   co_outer_text constant types_up.short_text_type := 'Outer Loop counter is ';
   co_inner_text constant types_up.short_text_type := ' Inner Loop counter is ';
   l_outerlp     pls_integer;
   l_innerlp     pls_integer;
begin
   l_outerlp := co_init_loop;
   &lt;&lt;outerloop&gt;&gt;
   loop
      l_innerlp := co_init_loop;
      l_outerlp := nvl(l_outerlp,co_init_loop) + co_increment;
      &lt;&lt;innerloop&gt;&gt;
      loop
         l_innerlp := nvl(l_innerlp,co_init_loop) + co_increment;
         sys.dbms_output.put_line(co_outer_text
            || l_outerlp
            || co_inner_text
            || l_innerlp);

         exit outerloop when l_innerlp = co_exit_value;
      end loop innerloop;
   end loop outerloop;
end;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-4385</key>
		<name><![CDATA[G-4385: Never use a cursor for loop to check whether a cursor returns data.]]></name>
		<internalKey>G-4385</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>You might process more data than required, which leads to bad performance.</p>
			<h2>Bad</h2>
<pre>declare
   l_employee_found boolean := false;
   cursor c_employees is
      select employee_id,last_name
        from employees;
begin
   &lt;&lt;check_employees&gt;&gt;
   for r_employee in c_employees
   loop
      l_employee_found := true;
   end loop check_employees;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_employee_found boolean := false;
   cursor c_employees is
      select employee_id,last_name
        from employees;
   r_employee       c_employees%rowtype;
begin
   open c_employees;
   fetch c_employees into r_employee;
   l_employee_found := c_employees%found;
   close c_employees;
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-4390</key>
		<name><![CDATA[G-4390: Avoid use of unreferenced FOR loop indexes.]]></name>
		<internalKey>G-4390</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>If the loop index is used for anything but traffic control inside the loop, this is one of the
			indicators that a numeric <code>for</code> loop is being used incorrectly. The actual body of executable
			statements completely ignores the loop index. When that is the case, there is a good chance that
			you do not need the loop at all.</p>
			<h2>Bad</h2>
<pre>declare
   l_row          pls_integer;
   l_value        pls_integer;
   co_lower_bound constant simple_integer           := 1;
   co_upper_bound constant simple_integer           := 5;
   co_row_incr    constant simple_integer           := 1;
   co_value_incr  constant simple_integer           := 10;
   co_delimiter   constant types_up.short_text_type := ' ';
   co_first_value constant simple_integer           := 100;
begin
   l_row   := co_lower_bound;
   l_value := co_first_value;
   &lt;&lt;for_loop&gt;&gt;
   for i in co_lower_bound..co_upper_bound
   loop
      sys.dbms_output.put_line(l_row
         || co_delimiter
         || l_value);
      l_row   := l_row + co_row_incr;
      l_value := l_value + co_value_incr;
   end loop for_loop;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   co_lower_bound constant simple_integer           := 1;
   co_upper_bound constant simple_integer           := 5;
   co_value_incr  constant simple_integer           := 10;
   co_delimiter   constant types_up.short_text_type := ' ';
   co_first_value constant simple_integer           := 100;
begin
   &lt;&lt;for_loop&gt;&gt;
   for i in co_lower_bound..co_upper_bound
   loop
      sys.dbms_output.put_line(i
         || co_delimiter
         || to_char(co_first_value + i * co_value_incr));
   end loop for_loop;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-4395</key>
		<name><![CDATA[G-4395: Avoid hard-coded upper or lower bound values with FOR loops.]]></name>
		<internalKey>G-4395</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Your <code>loop</code> statement uses a hard-coded value for either its upper or lower bounds. This creates
			a "weak link" in your program because it assumes that this value will never change. A better
			practice is to create a named constant (or function) and reference this named element instead of
			the hard-coded value.</p>
			<h2>Bad</h2>
<pre>begin
   &lt;&lt;for_loop&gt;&gt;
   for i in 1..5
   loop
      sys.dbms_output.put_line(i);
   end loop for_loop;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   co_lower_bound constant simple_integer := 1;
   co_upper_bound constant simple_integer := 5;
begin
   &lt;&lt;for_loop&gt;&gt;
   for i in co_lower_bound..co_upper_bound
   loop
      sys.dbms_output.put_line(i);
   end loop for_loop;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-5010</key>
		<name><![CDATA[G-5010: Try to use a error/logging framework for your application. (not implemented)]]></name>
		<internalKey>G-5010</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Having a framework to raise/handle/log your errors allows you to easily avoid duplicate
			application error numbers and having different error messages for the same type of error.</p>
			<p>This kind of framework should include</p>
			<ul>
			   <li>Logging (different channels like table, mail, file, etc. if needed)</li>
			   <li>Error Raising</li>
			   <li>Multilanguage support if needed</li>
			   <li>Translate Oracle Database error messages to a user friendly error text</li>
			   <li>Error repository</li>
			</ul>
			<h2>Bad</h2>
<pre>begin
   sys.dbms_output.put_line('START');
   -- some processing
   sys.dbms_output.put_line('END');
end;
/</pre>
			<h2>Good</h2>
<pre>declare 
   -- see https://github.com/OraOpenSource/Logger
   l_scope logger_logs.scope%type := 'DEMO';
begin
   logger.log('START',l_scope);
   -- some processing
   logger.log('END',l_scope);
end;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-5020</key>
		<name><![CDATA[G-5020: Never handle unnamed exceptions using the error number.]]></name>
		<internalKey>G-5020</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>When literals are used for error numbers the reader needs the error message manual to
			unterstand what is going on. Commenting the code or using constants is an option, but it is
			better to use named exceptions instead, because it ensures a certain level of consistency which
			makes maintenance easier.</p>
			<h2>Bad</h2>
<pre>declare
   co_no_data_found constant integer := -1;
begin
   my_package.some_processing(); -- some code which raises an exception
exception
   when too_many_rows then
      my_package.some_further_processing();
   when others then
      if sqlcode = co_no_data_found then
         null;
      end if;
end;
/</pre>
			<h2>Good</h2>
<pre>begin
   my_package.some_processing(); -- some code which raises an exception
exception
   when too_many_rows then
      my_package.some_further_processing();
   when no_data_found then
      null; -- handle no_data_found
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-5030</key>
		<name><![CDATA[G-5030: Never assign predefined exception names to user defined exceptions.]]></name>
		<internalKey>G-5030</internalKey>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>This is error-prone because your local declaration overrides the global declaration. While it is
			technically possible to use the same names, it causes confusion for others needing to read and
			maintain this code. Additionally, you will need to be very careful to use the prefix <code>standard</code> in
			front of any reference that needs to use the default exception behavior of the Oracle Database.</p>
			<h2>Bad</h2>
<pre>-- Using the code below, we are not able to handle the no_data_found exception raised by the
-- select statement as we have overwritten that exception handler. In addition, our exception
-- handler doesn't have an exception number assigned, which should be raised when the select
-- statement does not find any rows.
declare
   l_dummy          dual.dummy%type;
   no_data_found    exception;
   co_rownum        constant simple_integer           := 0;
   co_no_data_found constant types_up.short_text_type := 'no_data_found';
begin
   select dummy
     into l_dummy
     from dual
    where rownum = co_rownum;

   if l_dummy is null then
      raise no_data_found;
   end if;
exception
   when no_data_found then
      sys.dbms_output.put_line(co_no_data_found);
end;
/

/*
Error report -
ORA-01403: no data found
ORA-06512: at line 5
01403. 00000 -  "no data found"
*Cause:    No data was found from the objects.
*Action:   There was no data from the objects which may be due to end of fetch.
*/</pre>
			<h2>Good</h2>
<pre>declare
   l_dummy          dual.dummy%type;
   empty_value      exception;
   co_rownum        constant simple_integer           := 0;
   co_empty_value   constant types_up.short_text_type := 'empty_value';
   co_no_data_found constant types_up.short_text_type := 'no_data_found';
begin
   select dummy
     into l_dummy
     from dual
    where rownum = co_rownum;

   if l_dummy is null then
      raise empty_value;
   end if;
exception
   when empty_value then
      sys.dbms_output.put_line(co_empty_value);
   when no_data_found then
      sys.dbms_output.put_line(co_no_data_found);
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-5040</key>
		<name><![CDATA[G-5040: Avoid use of WHEN OTHERS clause in an exception section without any other specific handlers.]]></name>
		<internalKey>G-5040</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>There is not necessarily anything wrong with using <code>when others</code>, but it can cause you to "lose"
			error information unless your handler code is relatively sophisticated. Generally, you should use
			<code>when others</code> to grab any and every error only after you have thought about your executable
			section and decided that you are not able to trap any specific exceptions. If you know, on the
			other hand, that a certain exception might be raised, include a handler for that error. By declaring
			two different exception handlers, the code more clearly states what we expect to have happen
			and how we want to handle the errors. That makes it easier to maintain and enhance. We also
			avoid hard-coding error numbers in checks against <code>sqlcode</code>.</p>
			<p>When using a logging framework like Logger, consider making an exception to this rule and allow
			a when others even without other specific handlers, but only if the when others exception
			handler calls a logging procedure that saves the error stack (that otherwise is lost) and the last
			statement of the handler is <code>raise</code>.</p>
			<h2>Bad</h2>
<pre>begin
   my_package.some_processing();
exception
   when others then
      my_package.some_further_processing();
end;
/</pre>
			<h2>Good</h2>
<pre>begin
   my_package.some_processing();
exception
   when dup_val_on_index then
      my_package.some_further_processing();
end;
/

-- An exception to the rule where when others can be good to log the error and then re-raise it:
begin
   my_package.some_processing();
exception
   when others then
      logger.log_error('Unhandled Exception');
      raise;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-5050</key>
		<name><![CDATA[G-5050: Avoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded 20nnn error number or hard-coded message.]]></name>
		<internalKey>G-5050</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>If you are not very organized in the way you allocate, define and use the error numbers between
			20999 and 20000 (those reserved by by the Oracle Database for its user community), it is very easy to end up with
			conflicting usages. You should assign these error numbers to named constants and consolidate
			all definitions within a single package. When you call raise_application_error, you should
			reference these named elements and error message text stored in a table. Use your own raise
			procedure in place of explicit calls to raise_application_error. If you are raising a "system"
			exception like no_data_found, you must use raise. However, when you want to raise an
			application-specific error, you use raise_application_error. If you use the latter, you then have
			to provide an error number and message. This leads to unnecessary and damaging hard-coded
			values. A more fail-safe approach is to provide a predefined raise procedure that automatically
			checks the error number and determines the correct way to raise the error.</p>
			<h2>Bad</h2>
<pre>begin
   raise_application_error(-20501,'Invalid employee_id');
end;
/</pre>
			<h2>Good</h2>
<pre>begin
   err_up.raise(in_error =&gt; err.co_invalid_employee_id);
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-5060</key>
		<name><![CDATA[G-5060: Avoid unhandled exceptions]]></name>
		<internalKey>G-5060</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>This may be your intention, but you should review the code to confirm this behavior.</p>
			<p>If you are raising an error in a program, then you are clearly predicting a situation in which that
			error will occur. You should consider including a handler in your code for predictable errors,
			allowing for a graceful and informative failure. After all, it is much more difficult for an enclosing
			block to be aware of the various errors you might raise and more importantly, what should be
			done in response to the error.</p>
			<p>The form that this failure takes does not necessarily need to be an exception. When writing
			functions, you may well decide that in the case of certain exceptions, you will want to return a
			value such as <code>null</code>, rather than allow an exception to propagate out of the function.</p>
			<h2>Bad</h2>
<pre>create or replace package body department_api is
   function name_by_id(in_id in departments.department_id%type)
      return departments.department_name%type is
      l_department_name departments.department_name%type;
   begin
      select department_name
        into l_department_name
        from departments
       where department_id = in_id;

      return l_department_name;
   end name_by_id;
end department_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body department_api is
   function name_by_id(in_id in departments.department_id%type)
      return departments.department_name%type is
      l_department_name departments.department_name%type;
   begin
      select department_name
        into l_department_name
        from departments
       where department_id = in_id;

      return l_department_name;
   exception
      when no_data_found then
         return null;
      when too_many_rows then
         raise;
   end name_by_id;
end department_api;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-5070</key>
		<name><![CDATA[G-5070: Avoid using Oracle predefined exceptions]]></name>
		<internalKey>G-5070</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>You have raised an exception whose name was defined by Oracle. While it is possible that you
			have a good reason for "using" one of Oracle's predefined exceptions, you should make sure that
			you would not be better off declaring your own exception and raising that instead.</p>
			<p>If you decide to change the exception you are using, you should apply the same consideration to
			your own exceptions. Specifically, do not "re-use" exceptions. You should define a separate
			exception for each error condition, rather than use the same exception for different
			circumstances.</p>
			<p>Being as specific as possible with the errors raised will allow developers to check for, and handle,
			the different kinds of errors the code might produce.</p>
			<h2>Bad</h2>
<pre>begin
   raise no_data_found;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   my_exception exception;
begin
   raise my_exception;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-5080</key>
		<name><![CDATA[G-5080: Always use FORMAT_ERROR_BACKTRACE when using FORMAT_ERROR_STACK or SQLERRM.]]></name>
		<internalKey>G-5080</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>In exception handler <code>sqlerrm</code> and <code>format_error_stack</code> won't tell you the exact line where the
			error occurred. <code>format_error_backtrace</code> displays the call stack at the point where an exception
			was raised, even if the subprogram is called from an exception handler in an outer scope.</p>
			<p>If you use sqlerrm or <code>format_error_stack</code> to log/display error, you should also include
			<code>format_error_backtrace</code> to identify the exact location where the exception was raised.</p>
			<h2>Bad</h2>
<pre>create or replace package body order_api as
   procedure discount_and_recalculate(
      in_customer_id in customer.id%type
     ,in_discount    in customer.discount_percentage%type
   ) is
   begin
      customer_api.apply_discount(in_customer_id,in_discount);
      customer_api.in_customer_id(10293847);
   exception
      when zero_divide then
         null; -- ignore
      when others then
         logging_package.log_error('Error: ' || sqlerrm);
         raise;
   end discount_and_recalculate;
end order_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body order_api as
   procedure discount_and_recalculate(
      in_customer_id in customer.id%type
     ,in_discount    in customer.discount_percentage%type
   ) is
   begin
      customer_api.apply_discount(in_customer_id,in_discount);
      customer_api.in_customer_id(10293847);
   exception
      when zero_divide then
         null; -- ignore
      when others then
         logging_package.log_error(
            'Error: '
            || sqlerrm
            || ' - Backtrace: '
            || sys.dbms_utility.format_error_backtrace
         );
         raise;
   end discount_and_recalculate;
end order_api;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-6010</key>
		<name><![CDATA[G-6010: Always use a character variable to execute dynamic SQL.]]></name>
		<internalKey>G-6010</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Having the executed statement in a variable makes it easier to debug your code (e.g. by logging
			the statement that failed).</p>
			<h2>Bad</h2>
<pre>declare
   l_next_val employees.employee_id%type;
begin
   execute immediate 'select employees_seq.nextval from dual' into l_next_val;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_next_val employees.employee_id%type;
   co_sql     constant types_up.big_string_type :=
      'select employees_seq.nextval from dual';
begin
   execute immediate co_sql into l_next_val;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-6020</key>
		<name><![CDATA[G-6020: Try to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause.]]></name>
		<internalKey>G-6020</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>When a dynamic <code>insert</code>, <code>update</code>, or <code>delete</code> statement has a returning clause, output bind
			arguments can go in the <code>returning into</code> clause or in the using clause.</p>
			<p>You should use the <code>returning into</code> clause for values returned from a DML operation.
			Reserve <code>out</code> and <code>in out bind</code> variables for dynamic PL/SQL blocks that return values in PL/SQL
			variables.</p>
			<h2>Bad</h2>
<pre>create or replace package body employee_api is
   procedure upd_salary(in_employee_id  in  employees.employee_id%type
                       ,in_increase_pct in  types_up.percentage
                       ,out_new_salary  out employees.salary%type)
   is
      co_sql_stmt constant types_up.big_string_type := '
           update employees set salary = salary + (salary / 100 * :1) 
            where employee_id = :2
        returning salary into :3';
   begin
      execute immediate co_sql_stmt
         using in_increase_pct,in_employee_id,out out_new_salary;
   end upd_salary;
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api is
   procedure upd_salary(in_employee_id  in  employees.employee_id%type
                       ,in_increase_pct in  types_up.percentage
                       ,out_new_salary  out employees.salary%type)
   is
      co_sql_stmt constant types_up.big_string_type :=
         'update employees set salary = salary + (salary / 100 * :1) 
            where employee_id = :2
        returning salary into :3';
   begin
      execute immediate co_sql_stmt
         using in_increase_pct,in_employee_id
         returning into out_new_salary;
   end upd_salary;
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-7110</key>
		<name><![CDATA[G-7110: Try to use named notation when calling program units.]]></name>
		<internalKey>G-7110</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Named notation makes sure that changes to the signature of the called program unit do not
			affect your call.</p>
			<p>This is not needed for standard functions like (<code>to_char</code>, <code>to_date</code>, <code>nvl</code>, <code>round</code>, etc.) but should
			be followed for any other stored object having more than one parameter.</p>
			<h2>Bad</h2>
<pre>declare
   r_employee employees%rowtype;
   co_id      constant employees.employee_id%type := 107;
begin
   employee_api.employee_by_id(r_employee,co_id);
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   r_employee employees%rowtype;
   co_id      constant employees.employee_id%type := 107;
begin
   employee_api.employee_by_id(out_row =&gt; r_employee,in_employee_id =&gt; co_id);
end;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-7120</key>
		<name><![CDATA[G-7120: Always add the name of the program unit to its end keyword.]]></name>
		<internalKey>G-7120</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>It's a good alternative for comments to indicate the end of program units, especially if they are
			lengthy or nested.</p>
			
			<p></p>
			<h2>Bad</h2>
<pre>create or replace package body employee_api is
   function employee_by_id(in_employee_id in employees.employee_id%type)
      return employees%rowtype is
      r_employee employees%rowtype;
   begin
      select *
        into r_employee
        from employees
       where employee_id = in_employee_id;

      return r_employee;
   exception
      when no_data_found then
         null;
      when too_many_rows then
         raise;
   end;
end;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api is
   function employee_by_id(in_employee_id in employees.employee_id%type)
      return employees%rowtype is
      r_employee employees%rowtype;
   begin
      select *
        into r_employee
        from employees
       where employee_id = in_employee_id;

      return r_employee;
   exception
      when no_data_found then
         null;
      when too_many_rows then
         raise;
   end employee_by_id;
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-7125</key>
		<name><![CDATA[G-7125: Always use CREATE OR REPLACE instead of CREATE alone.]]></name>
		<internalKey>G-7125</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Using create alone makes your scripts give an error if the program unit already exists, which
			makes the script not repeatable. It is good practice to use create or replace to avoid such errors.</p>
			
			<p></p>
			<h2>Bad</h2>
<pre>create package body employee_api is
   function employee_by_id(in_employee_id in employees.employee_id%type)
      return employees%rowtype is
      r_employee employees%rowtype;
   begin
      select *
        into r_employee
        from employees
       where employee_id = in_employee_id;

      return r_employee;
   exception
      when no_data_found then
         null;
      when too_many_rows then
         raise;
   end employee_by_id;
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api is
   function employee_by_id(in_employee_id in employees.employee_id%type)
      return employees%rowtype is
      r_employee employees%rowtype;
   begin
      select *
        into r_employee
        from employees
       where employee_id = in_employee_id;

      return r_employee;
   exception
      when no_data_found then
         null;
      when too_many_rows then
         raise;
   end employee_by_id;
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-7130</key>
		<name><![CDATA[G-7130: Always use parameters or pull in definitions rather than referencing external variables in a local program unit.]]></name>
		<internalKey>G-7130</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Local procedures and functions offer an excellent way to avoid code redundancy and make your
			code more readable (and thus more maintainable). Your local program refers, however, an
			external data structure, i.e., a variable that is declared outside of the local program. Thus, it is
			acting as a global variable inside the program.</p>
			<p>This external dependency is hidden, and may cause problems in the future. You should instead
			add a parameter to the parameter list of this program and pass the value through the list. This
			technique makes your program more reusable and avoids scoping problems, i.e. the program unit
			is less tied to particular variables in the program. In addition, unit encapsulation makes
			maintenance a lot easier and cheaper.</p>
			<h2>Bad</h2>
<pre>create or replace package body employee_api is
   procedure calc_salary(in_employee_id in employees.employee_id%type) is
      r_emp employees%rowtype;

      function commission return number is
         l_commission employees.salary%type := 0;
      begin
         if r_emp.commission_pct is not null then
            l_commission := r_emp.salary * r_emp.commission_pct;
         end if;

         return l_commission;
      end commission;
   begin
      select *
        into r_emp
        from employees
       where employee_id = in_employee_id;

      sys.dbms_output.put_line(r_emp.salary + commission());
   exception
      when no_data_found then
         null;
      when too_many_rows then
         null;
   end calc_salary;
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api is
   procedure calc_salary(in_employee_id in employees.employee_id%type) is
      r_emp employees%rowtype;

      function commission(in_salary   in employees.salary%type
                         ,in_comm_pct in employees.commission_pct%type)
         return number is
         l_commission employees.salary%type := 0;
      begin
         if in_comm_pct is not null then
            l_commission := in_salary * in_comm_pct;
         end if;

         return l_commission;
      end commission;
   begin
      select *
        into r_emp
        from employees
       where employee_id = in_employee_id;

      sys.dbms_output.put_line(
         r_emp.salary + commission(in_salary   =&gt; r_emp.salary
                                  ,in_comm_pct =&gt; r_emp.commission_pct)
      );
   exception
      when no_data_found then
         null;
      when too_many_rows then
         null;
   end calc_salary;
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-7140</key>
		<name><![CDATA[G-7140: Always ensure that locally defined procedures or functions are referenced.]]></name>
		<internalKey>G-7140</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>This can occur as the result of changes to code over time, but you should make sure that this
			situation does not reflect a problem. And you should remove the declaration to avoid
			maintenance errors in the future.</p>
			<p>You should go through your programs and remove any part of your code that is no longer used.
			This is a relatively straightforward process for variables and named constants. Simply execute
			searches for a variable's name in that variable's scope. If you find that the only place it appears is
			in its declaration, delete the declaration.</p>
			<p>There is never a better time to review all the steps you took, and to understand the reasons you
			took them, then immediately upon completion of your program. If you wait, you will find it
			particularly difficult to remember those parts of the program that were needed at one point,
			but were rendered unnecessary in the end.</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   procedure my_procedure is
      function my_func return number is
         co_true constant integer := 1;
      begin
         return co_true;
      end my_func;
   begin
      null;
   end my_procedure;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   procedure my_procedure is
      function my_func return number is
         co_true constant integer := 1;
      begin
         return co_true;
      end my_func;
   begin
      sys.dbms_output.put_line(my_func());
   end my_procedure;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-7150</key>
		<name><![CDATA[G-7150: Try to remove unused parameters.]]></name>
		<internalKey>G-7150</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>You should go through your programs and remove any parameter that is no longer used.</p>
			<h2>Bad</h2>
<pre>create or replace package body department_api is
   function name_by_id(in_department_id in departments.department_id%type
                      ,in_manager_id    in departments.manager_id%type)
      return departments.department_name%type is
      l_department_name departments.department_name%type;
   begin
      &lt;&lt;find_department&gt;&gt;
      begin
         select department_name
           into l_department_name
           from departments
          where department_id = in_department_id;
      exception
         when no_data_found or too_many_rows then
            l_department_name := null;
      end find_department;

      return l_department_name;
   end name_by_id;
end department_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body department_api is
   function name_by_id(in_department_id in departments.department_id%type)
      return departments.department_name%type is
      l_department_name departments.department_name%type;
   begin
      &lt;&lt;find_department&gt;&gt;
      begin
         select department_name
           into l_department_name
           from departments
          where department_id = in_department_id;
      exception
         when no_data_found or too_many_rows then
            l_department_name := null;
      end find_department;

      return l_department_name;
   end name_by_id;
end department_api;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-7160</key>
		<name><![CDATA[G-7160: Always explicitly state parameter mode.]]></name>
		<internalKey>G-7160</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>By showing the mode of parameters, you help the reader. If you do not specify a parameter mode,
			the default mode is <code>in</code>. Explicitly showing the mode indication of all parameters is a more
			assertive action than simply taking the default mode. Anyone reviewing the code later will be
			more confident that you intended the parameter mode to be <code>in</code>, <code>out</code> or <code>in out</code>.</p>
			<h2>Bad</h2>
<pre>create or replace package employee_api is
   procedure store(io_id       in out employees.id%type
                  ,in_first_name      employees.first_name%type
                  ,in_last_name       employees.last_name%type
                  ,in_email           employees.email%type
                  ,in_department_id   employees.department_id%type
                  ,out_success out    pls_integer);
end employee_up;
/</pre>
			<h2>Good</h2>
<pre>create or replace package employee_api is
   procedure store(io_id            in out employees.id%type
                  ,in_first_name    in     employees.first_name%type
                  ,in_last_name     in     employees.last_name%type
                  ,in_email         in     employees.email%type
                  ,in_department_id in     employees.department_id%type
                  ,out_success      out    pls_integer);
end employee_up;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-7170</key>
		<name><![CDATA[G-7170: Avoid using an IN OUT parameter as IN or OUT only. (not implemented)]]></name>
		<internalKey>G-7170</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Avoid using parameter mode <code>in out</code> unless you actually use the parameter both as input and
			output. If the code body only reads from the parameter, use <code>in</code>; if the code body only assigns to
			the parameter, use <code>out</code>. If at the beginning of a project you expect a parameter to be both input
			and output and therefore choose <code>in out</code> just in case, but later development shows the
			parameter actually is only <code>in</code> or <code>out</code>, you should change the parameter mode accordingly.</p>
			<h2>Bad</h2>
<pre>create or replace package body employee_up is
   procedure rcv_emp(io_first_name     in out employees.first_name%type
                    ,io_last_name      in out employees.last_name%type
                    ,io_email          in out employees.email%type
                    ,io_phone_number   in out employees.phone_number%type
                    ,io_hire_date      in out employees.hire_date%type
                    ,io_job_id         in out employees.job_id%type
                    ,io_salary         in out employees.salary%type
                    ,io_commission_pct in out employees.commission_pct%type
                    ,io_manager_id     in out employees.manager_id%type
                    ,io_department_id  in out employees.department_id%type
                    ,in_wait           in     integer) is
      l_status          pls_integer;
      co_dflt_pipe_name constant string(30 char) := 'MyPipe';
      co_ok             constant pls_integer     := 1;
   begin
      -- Receive next message and unpack for each column. 
      l_status := sys.dbms_pipe.receive_message(pipename =&gt; co_dflt_pipe_name
                                               ,timeout  =&gt; in_wait);
      if l_status = co_ok then
         sys.dbms_pipe.unpack_message(io_first_name);
         sys.dbms_pipe.unpack_message(io_last_name);
         sys.dbms_pipe.unpack_message(io_email);
         sys.dbms_pipe.unpack_message(io_phone_number);
         sys.dbms_pipe.unpack_message(io_hire_date);
         sys.dbms_pipe.unpack_message(io_job_id);
         sys.dbms_pipe.unpack_message(io_salary);
         sys.dbms_pipe.unpack_message(io_commission_pct);
         sys.dbms_pipe.unpack_message(io_manager_id);
         sys.dbms_pipe.unpack_message(io_department_id);
      end if;
   end rcv_emp;
end employee_up;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_up is
   procedure rcv_emp(out_first_name     out employees.first_name%type
                    ,out_last_name      out employees.last_name%type
                    ,out_email          out employees.email%type
                    ,out_phone_number   out employees.phone_number%type
                    ,out_hire_date      out employees.hire_date%type
                    ,out_job_id         out employees.job_id%type
                    ,out_salary         out employees.salary%type
                    ,out_commission_pct out employees.commission_pct%type
                    ,out_manager_id     out employees.manager_id%type
                    ,out_department_id  out employees.department_id%type
                    ,in_wait            in  integer) is
      l_status          pls_integer;
      co_dflt_pipe_name constant string(30 char) := 'MyPipe';
      co_ok             constant pls_integer     := 1;
   begin
      -- Receive next message and unpack for each column. 
      l_status := sys.dbms_pipe.receive_message(pipename =&gt; co_dflt_pipe_name
                                               ,timeout  =&gt; in_wait);
      if l_status = co_ok then
         sys.dbms_pipe.unpack_message(out_first_name);
         sys.dbms_pipe.unpack_message(out_last_name);
         sys.dbms_pipe.unpack_message(out_email);
         sys.dbms_pipe.unpack_message(out_phone_number);
         sys.dbms_pipe.unpack_message(out_hire_date);
         sys.dbms_pipe.unpack_message(out_job_id);
         sys.dbms_pipe.unpack_message(out_salary);
         sys.dbms_pipe.unpack_message(out_commission_pct);
         sys.dbms_pipe.unpack_message(out_manager_id);
         sys.dbms_pipe.unpack_message(out_department_id);
      end if;
   end rcv_emp;
end employee_up;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-7210</key>
		<name><![CDATA[G-7210: Try to keep your packages small. Include only few procedures and functions that are used in the same context.]]></name>
		<internalKey>G-7210</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The entire package is loaded into memory when the package is called the first time. To optimize
			memory consumption and keep load time small packages should be kept small but include
			components that are used together.</p>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-7220</key>
		<name><![CDATA[G-7220: Always use forward declaration for private functions and procedures.]]></name>
		<internalKey>G-7220</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Having forward declarations allows you to order the functions and procedures of the package in
			a reasonable way.</p>
			<h2>Bad</h2>
<pre>create or replace package department_api is
   procedure del(in_department_id in departments.department_id%type);
end department_api;
/

create or replace package body department_api is
   function does_exist(in_department_id in departments.department_id%type)
      return boolean is
      l_return pls_integer;
   begin
      &lt;&lt;check_row_exists&gt;&gt;
      begin
         select 1
           into l_return
           from departments
          where department_id = in_department_id;
      exception
         when no_data_found or too_many_rows then
            l_return := 0;
      end check_row_exists;

      return l_return = 1;
   end does_exist;

   procedure del(in_department_id in departments.department_id%type) is
   begin
      if does_exist(in_department_id) then
         null;
      end if;
   end del;
end department_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package department_api is
   procedure del(in_department_id in departments.department_id%type);
end department_api;
/

create or replace package body department_api is
   function does_exist(in_department_id in departments.department_id%type)
      return boolean;

   procedure del(in_department_id in departments.department_id%type) is
   begin
      if does_exist(in_department_id) then
         null;
      end if;
   end del;

   function does_exist(in_department_id in departments.department_id%type)
      return boolean is
      l_return pls_integer;
   begin
      &lt;&lt;check_row_exists&gt;&gt;
      begin
         select 1
           into l_return
           from departments
          where department_id = in_department_id;
      exception
         when no_data_found or too_many_rows then
            l_return := 0;
      end check_row_exists;

      return l_return = 1;
   end does_exist;
end department_api;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-7230</key>
		<name><![CDATA[G-7230: Avoid declaring global variables public.]]></name>
		<internalKey>G-7230</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>You should always declare package-level data (non-constants) inside the package body. You can
			then define "get and set" methods (functions and procedures, respectively) in the package
			specification to provide controlled access to that data. By doing so you can guarantee data
			integrity, you can change your data structure implementation, and also track access to those
			data structures.</p>
			<p>Data structures (scalar variables, collections, cursors) declared in the package specification (not
			within any specific program) can be referenced directly by any program running in a session with
			execute rights to the package.</p>
			<p>Instead, declare all package-level data in the package body and provide "get and set" methods - a
			function to get the value and a procedure to set the value - in the package specification.
			Developers then can access the data using these methods - and will automatically follow all rules
			you set upon data modification.</p>
			<p>For package-level constants, consider whether the constant should be public and usable from
			other code, or if only relevant for code within the package. If the latter, declare the constant in the
			package body. If the former, it is typically good practice to place the constants in a package
			specification that only holds constants.</p>
			<h2>Bad</h2>
<pre>create or replace package employee_api as
   co_min_increase constant types_up.sal_increase_type := 0.01;
   co_max_increase constant types_up.sal_increase_type := 0.5;
   g_salary_increase types_up.sal_increase_type := co_min_increase;

   procedure set_salary_increase(in_increase in types_up.sal_increase_type);
   function salary_increase return types_up.sal_increase_type;
end employee_api;
/

create or replace package body employee_api as
   procedure set_salary_increase(in_increase in types_up.sal_increase_type) is
   begin
      g_salary_increase := greatest(least(in_increase,co_max_increase)
                                   ,co_min_increase);
   end set_salary_increase;

   function salary_increase return types_up.sal_increase_type is
   begin
      return g_salary_increase;
   end salary_increase;
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package constants_up as
   co_min_increase constant types_up.sal_increase_type := 0.01;
   co_max_increase constant types_up.sal_increase_type := 0.5;
end constants_up;
/

create or replace package employee_api as
   procedure set_salary_increase(in_increase in types_up.sal_increase_type);
   function salary_increase return types_up.sal_increase_type;
end employee_api;
/

create or replace package body employee_api as
   g_salary_increase types_up.sal_increase_type(4,2);

   procedure init;

   procedure set_salary_increase(in_increase in types_up.sal_increase_type) is
   begin
      g_salary_increase := greatest(least(in_increase,constants_up.co_max_increase)
                                   ,constants_up.co_min_increase);
   end set_salary_increase;

   function salary_increase return types_up.sal_increase_type is
   begin
      return g_salary_increase;
   end salary_increase;

   procedure init
   is
   begin
      g_salary_increase := constants_up.co_min_increase;
   end init;
begin
   init();
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-7250</key>
		<name><![CDATA[G-7250: Never use RETURN in package initialization block.]]></name>
		<internalKey>G-7250</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The purpose of the initialization block of a package body is to set initial values of the global
			variables of the package (initialize the package state). Although <code>return</code> is syntactically allowed
			in this block, it makes no sense. If it is the last keyword of the block, it is superfluous. If it is not
			the last keyword, then all code after the <code>return</code> is unreachable and thus dead code.</p>
			<h2>Bad</h2>
<pre>create or replace package body employee_api as
   g_salary_increase types_up.sal_increase_type(4,2);

   procedure set_salary_increase(in_increase in types_up.sal_increase_type) is
   begin
      g_salary_increase := greatest(least(in_increase,constants_up.max_salary_increase())
                                   ,constants_up.min_salary_increase());
   end set_salary_increase;

   function salary_increase return types_up.sal_increase_type is
   begin
      return g_salary_increase;
   end salary_increase;

begin
   g_salary_increase := constants_up.min_salary_increase();

   return;

   set_salary_increase(constants_up.min_salary_increase()); -- dead code
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api as
   g_salary_increase types_up.sal_increase_type(4,2);

   procedure set_salary_increase(in_increase in types_up.sal_increase_type) is
   begin
      g_salary_increase := greatest(least(in_increase,constants_up.max_salary_increase())
                                   ,constants_up.min_salary_increase());
   end set_salary_increase;

   function salary_increase return types_up.sal_increase_type is
   begin
      return g_salary_increase;
   end salary_increase;

begin
   g_salary_increase := constants_up.min_salary_increase();
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-7310</key>
		<name><![CDATA[G-7310: Avoid standalone procedures – put your procedures in packages.]]></name>
		<internalKey>G-7310</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Use packages to structure your code, combine procedures and functions which belong together.</p>
			<p>Package bodies may be changed and compiled without invalidating other packages. This is a
			major advantage compared to standalone procedures and functions.</p>
			<h2>Bad</h2>
<pre>create or replace procedure my_procedure is
begin
   null;
end my_procedure;
/</pre>
			<h2>Good</h2>
<pre>create or replace package my_package is
   procedure my_procedure;
end my_package;
/

create or replace package body my_package is
   procedure my_procedure is
   begin
      null;
   end my_procedure;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-7320</key>
		<name><![CDATA[G-7320: Avoid using RETURN statements in a PROCEDURE.]]></name>
		<internalKey>G-7320</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Use of the <code>return</code> statement is legal within a procedure in PL/SQL, but it is very similar to a
			<code>goto</code>, which means you end up with poorly structured code that is hard to debug and maintain.</p>
			<p>A good general rule to follow as you write your PL/SQL programs is "one way in and one way out".
			In other words, there should be just one way to enter or call a program, and there should be one
			way out, one exit path from a program (or loop) on successful termination. By following this rule,
			you end up with code that is much easier to trace, debug, and maintain.</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   procedure my_procedure is
      l_idx     simple_integer          := 1;
      co_modulo constant simple_integer := 7;
   begin
      &lt;&lt;mod7_loop&gt;&gt;
      loop
         if mod(l_idx,co_modulo) = 0 then
            return;
         end if;

         l_idx := l_idx + 1;
      end loop mod7_loop;
   end my_procedure;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   procedure my_procedure is
      l_idx     simple_integer          := 1;
      co_modulo constant simple_integer := 7;
   begin
      &lt;&lt;mod7_loop&gt;&gt;
      loop
         exit mod7_loop when mod(l_idx,co_modulo) = 0;

         l_idx := l_idx + 1;
      end loop mod7_loop;
   end my_procedure;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-7330</key>
		<name><![CDATA[G-7330: Always assign values to OUT parameters.]]></name>
		<internalKey>G-7330</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Marking a parameter for output means that callers will expect its value to be updated with a
			result from the execution of the procedure. Failing to update the parameter before the procedure
			returns is surely an error.</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   procedure greet(
      in_name      in  varchar2
     ,out_greeting out varchar2
   ) is
      l_message varchar2(100 char);
   begin
      l_message := 'Hello, ' || in_name;
   end greet;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   procedure greet(
      in_name      in  varchar2
     ,out_greeting out varchar2
   ) is
   begin
      out_greeting := 'Hello, ' || in_name;
   end greet;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-7410</key>
		<name><![CDATA[G-7410: Avoid standalone functions – put your functions in packages.]]></name>
		<internalKey>G-7410</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Use packages to structure your code, combine procedures and functions which belong together.</p>
			<p>Package bodies may be changed and compiled without invalidating other packages. This is a 
			major advantage compared to standalone procedures and functions.</p>
			<h2>Bad</h2>
<pre>create or replace function my_function return varchar2 is
begin
   return null;
end my_function;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   function my_function return varchar2 is
   begin
      return null;
   end my_function;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-7420</key>
		<name><![CDATA[G-7420: Always make the RETURN statement the last statement of your function.]]></name>
		<internalKey>G-7420</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The reader expects the <code>return</code> statement to be the last statement of a function.</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   function my_function(in_from in pls_integer
                       ,in_to   in pls_integer) return pls_integer is
      l_ret pls_integer;
   begin
      l_ret := in_from;
      &lt;&lt;for_loop&gt;&gt;
      for i in in_from..in_to
      loop
         l_ret := l_ret + i;
         if i = in_to then
            return l_ret;
         end if;
      end loop for_loop;
   end my_function;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   function my_function(in_from in pls_integer
                       ,in_to   in pls_integer) return pls_integer is
      l_ret pls_integer;
   begin
      l_ret := in_from;
      &lt;&lt;for_loop&gt;&gt;
      for i in in_from..in_to
      loop
         l_ret := l_ret + i;
      end loop for_loop;
      return l_ret;
   end my_function;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-7430</key>
		<name><![CDATA[G-7430: Try to use no more than one RETURN statement within a function.]]></name>
		<internalKey>G-7430</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>A function should have a single point of entry as well as a single exit-point.</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   function my_function(in_value in pls_integer) return boolean is
      co_yes constant pls_integer := 1;
   begin
      if in_value = co_yes then
         return true;
      else
         return false;
      end if;
   end my_function;
end my_package;
/</pre>
			<h2>Better</h2>
<pre>create or replace package body my_package is
   function my_function(in_value in pls_integer) return boolean is
      co_yes constant pls_integer := 1;
      l_ret  boolean;
   begin
      if in_value = co_yes then
         l_ret := true;
      else
         l_ret := false;
      end if;

      return l_ret;
   end my_function;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   function my_function(in_value in pls_integer) return boolean is
      co_yes constant pls_integer := 1;
   begin
      return in_value = co_yes;
   end my_function;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-7440</key>
		<name><![CDATA[G-7440: Never use OUT parameters to return values from a function.]]></name>
		<internalKey>G-7440</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>A function should return all its data through the <code>return</code> clause. Having an <code>out</code> parameter
			prohibits usage of a function within SQL statements.</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   function my_function(out_date out date) return boolean is
   begin
      out_date := sysdate;
      return true;
   end my_function;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   function my_function return date is
   begin
      return sysdate;
   end my_function;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-7450</key>
		<name><![CDATA[G-7450: Never return a NULL value from a BOOLEAN function.]]></name>
		<internalKey>G-7450</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>If a boolean function returns <code>null</code>, the caller has do deal with it. This makes the usage
			cumbersome and more error-prone.</p>
			<h2>Bad</h2>
<pre>create or replace package body my_package is
   function my_function return boolean is
   begin
      return null;
   end my_function;
end my_package;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body my_package is
   function my_function return boolean is
   begin
      return true;
   end my_function;
end my_package;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-7460</key>
		<name><![CDATA[G-7460: Try to define your packaged/standalone function deterministic if appropriate.]]></name>
		<internalKey>G-7460</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>A deterministic function (always return same result for identical parameters) which is defined
			to be deterministic will be executed once per different parameter within a SQL statement whereas if
			the function is not defined to be deterministic it is executed once per result row.</p>
			<h2>Bad</h2>
<pre>create or replace package department_api is
   function name_by_id(in_department_id in departments.department_id%type)
      return departments.department_name%type;
end department_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package department_api is
   function name_by_id(in_department_id in departments.department_id%type)
      return departments.department_name%type
      deterministic;
end department_api;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-7510</key>
		<name><![CDATA[G-7510: Always prefix Oracle supplied packages with owner schema name.]]></name>
		<internalKey>G-7510</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The signature of Oracle supplied packages is well known and therefore it is quite easy to provide
			packages with the same name as those from Oracle doing something completely different
			without you noticing it.</p>
			<h2>Bad</h2>
<pre>declare
   co_hello_world constant string(30 char) := 'Hello World';
begin
   dbms_output.put_line(co_hello_world);
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   co_hello_world constant string(30 char) := 'Hello World';
begin
   sys.dbms_output.put_line(co_hello_world);
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-7710</key>
		<name><![CDATA[G-7710: Avoid cascading triggers.]]></name>
		<internalKey>G-7710</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Having triggers that act on other tables in a way that causes triggers on that table to fire lead to
			obscure behavior.</p>
			<h2>Bad</h2>
<pre>create or replace trigger dept_br_u
before update on departments for each row
begin
   insert into departments_hist (
      department_id
     ,department_name
     ,manager_id
     ,location_id
     ,modification_date)
   values (
      :old.department_id
     ,:old.department_name
     ,:old.manager_id
     ,:old.location_id
     ,sysdate);
end;
/
create or replace trigger dept_hist_br_i
before insert on departments_hist for each row
begin
   insert into departments_log (
      department_id
     ,department_name
     ,modification_date)
   values (
      :new.department_id
     ,:new.department_name
     ,sysdate);
end;
/</pre>
			<h2>Good</h2>
<pre>create or replace trigger dept_br_u
before update on departments for each row
begin
   insert into departments_hist (
      department_id
     ,department_name
     ,manager_id
     ,location_id
     ,modification_date)
   values (
      :old.department_id
     ,:old.department_name
     ,:old.manager_id
     ,:old.location_id
     ,sysdate);

   insert into departments_log (
      department_id
     ,department_name
     ,modification_date)
   values (
      :old.department_id
     ,:old.department_name
     ,sysdate);

end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-7720</key>
		<name><![CDATA[G-7720: Never use multiple UPDATE OF in trigger event clause.]]></name>
		<internalKey>G-7720</internalKey>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>A DML trigger can have multiple triggering events separated by <code>or</code> like <code>before insert or
			delete or update of some_column</code>. If you have multiple <code>update of</code> separated by <code>or</code>, only one
			of them (the last one) is actually used and you get no error message, so you have a bug waiting
			to happen. Instead you always should use a single <code>update of</code> with all columns comma-separated,
			or an <code>update</code> without of if you wish all columns.</p>
			<h2>Bad</h2>
<pre>create or replace trigger dept_br_u
before update of department_id or update of department_name
on departments for each row
begin
   -- will only fire on updates of department_name
   insert into departments_log (
      department_id
     ,department_name
     ,modification_date)
   values (
      :old.department_id
     ,:old.department_name
     ,sysdate);
end;
/</pre>
			<h2>Good</h2>
<pre>create or replace trigger dept_br_u
before update of department_id,department_name
on departments for each row
begin
   insert into departments_log (
      department_id
     ,department_name
     ,modification_date)
   values (
      :old.department_id
     ,:old.department_name
     ,sysdate);
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-7730</key>
		<name><![CDATA[G-7730: Avoid multiple DML events per trigger.]]></name>
		<internalKey>G-7730</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Rather than a single trigger handling multiple DML events with separated blocks of "if inserting",
			"if updating" and "if deleting", modularity by individual triggers per DML event helps maintaining
			and testing the code. If most of the code is common for either DML event (only small pieces of code are
			individual) consider an exception to the rule and allow "if inserting", "if updating" and "if deleting" 
			blocks, or alternatively gather the common code in a procedure and let individual triggers handle the
			individual pieces of code plus call the procedure with the common code.</p>
			<p>
			If the trigger makes assignment to a primary key and there are child tables with a foreign key referring
			to this primary key, the database can make undesirable table locks. If such is the case, you should
			always use individual triggers. See G-7740 for details.</p>
			<h2>Bad</h2>
<pre>create or replace trigger dept_br_iu
before insert or update
on departments for each row
begin
   if inserting then
      :new.created_date := sysdate;
   end if;
   if updating then
      :new.changed_date := sysdate;
   end if;
end;
/</pre>
			<h2>Good</h2>
<pre>create or replace trigger dept_br_i
before insert
on departments for each row
begin
   :new.created_date := sysdate;
end;
/

create or replace trigger dept_br_u
before update
on departments for each row
begin
   :new.changed_date := sysdate;
end;
/</pre>
			<p></p>]]></description>
		<tag>avoid</tag>
	</rule>
	<rule>
		<key>G-7740</key>
		<name><![CDATA[G-7740: Never handle multiple DML events per trigger if primary key is assigned in trigger. (not implemented)]]></name>
		<internalKey>G-7740</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>If a trigger makes assignment to the primary key anywhere in the trigger code, that causes the
			 session firing the trigger to take a lock on any child tables with a foreign key to this primary key.
			 Even if the assignment is in for example an "if inserting" block and the trigger is fired by an
			 update statement, such locks still happen unnecessarily. The issue is avoided by having one
			 trigger for the insert containing the primary key assignment, and another trigger for the update.
			 Or even better by handling the insert assignment as ´default on null´ clauses, so that only an 
			 "on update" trigger is needed.</p>
			<p>This locking of child tables behaviour goes for simple DML triggers as well as compound DML
			triggers where assignments to primary keys take place. It is not relevant for instead-of triggers on
			views, as it is not possible to assign :new values and therefore no locks on child tables are needed.</p>
			<h2>Bad</h2>
<pre>create or replace trigger dept_br_iu
before insert or update
on departments for each row
begin
   if inserting then
      :new.department_id := department_seq.nextval;
      :new.created_date  := sysdate;
   end if;
   if updating then
      :new.changed_date := sysdate;
   end if;
end;
/</pre>
			<h2>Good</h2>
<pre>create or replace trigger dept_br_i
before insert
on departments for each row
begin
   :new.department_id := department_seq.nextval;
   :new.created_date  := sysdate;
end;
/

create or replace trigger dept_br_u
before update
on departments for each row
begin
   :new.changed_date := sysdate;
end;
/</pre>
			<h2>Best</h2>
<pre>alter table department modify department_id default on null department_seq.nextval;
alter table department modify created_date  default on null sysdate;

create or replace trigger dept_br_u
before update
on departments for each row
begin
   :new.changed_date := sysdate;
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-7810</key>
		<name><![CDATA[G-7810: Never use SQL inside PL/SQL to read sequence numbers (or SYSDATE).]]></name>
		<internalKey>G-7810</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Since Oracle Database 11g it is no longer needed to use a <code>select</code> statement to read a sequence (which
			would imply a context switch).</p>
			<h2>Bad</h2>
<pre>declare
   l_sequence_number employees.employee_id%type;
begin
   select employees_seq.nextval
     into l_sequence_number
     from dual;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_sequence_number employees.employee_id%type;
begin
   l_sequence_number := employees_seq.nextval;
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-7910</key>
		<name><![CDATA[G-7910: Never use DML within a SQL macro.]]></name>
		<internalKey>G-7910</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Restriction</h2>
			<p>Oracle Database 21c (19c from version 19.7 for table macros alone)</p>
			<h2>Reason</h2>
			<p>Doing DML (except for select) within a SQL macro can lead to disastrous side effects from
			calling the macro in a SQL query.</p>
			<p>Logging macro calls via a call to a procedure that does DML in an autonomous transaction can
			be an exception to the rule.</p>
			<h2>Bad</h2>
<pre>create or replace function row_generator(
   in_num_rows in number
)
   return varchar2 sql_macro as
begin
   insert into function_calls(name,called_at,parameter_value)
   values ($$plsql_unit,current_timestamp,in_num_rows);
   commit;

   return 'select level as row_sequence
             from dual 
          connect by level &lt;= in_num_rows';
end row_generator;
/</pre>
			<h2>Good</h2>
<pre>create or replace function row_generator(
   in_num_rows in number
)
   return varchar2 sql_macro as
begin
   return 'select level as row_sequence
             from dual 
          connect by level &lt;= in_num_rows';
end row_generator;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-8110</key>
		<name><![CDATA[G-8110: Never use SELECT COUNT(*) if you are only interested in the existence of a row.]]></name>
		<internalKey>G-8110</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>If you do a <code>select count(*)</code> all rows will be read according to the <code>where</code> clause, even if only the
			availability of data is of interest. For this we have a big performance overhead. If we do a <code>select
			count(*) ... where rownum = 1</code> there is also a overhead as there will be two communications
			between the PL/SQL and the SQL engine. See the following example for a better solution.</p>
			<h2>Bad</h2>
<pre>declare
   l_count   pls_integer;
   co_zero   constant simple_integer        := 0;
   co_salary constant employees.salary%type := 5000;
begin
   select count(*)
     into l_count
     from employees
    where salary &lt; co_salary;
   if l_count &gt; co_zero then
      &lt;&lt;emp_loop&gt;&gt;
      for r_emp in (
         select employee_id
           from employees
      )
      loop
         if r_emp.salary &lt; co_salary then
            my_package.my_proc(in_employee_id =&gt; r_emp.employee_id);
         end if;
      end loop emp_loop;
   end if;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   co_salary constant employees.salary%type := 5000;
begin
   &lt;&lt;emp_loop&gt;&gt;
   for r_emp in (
      select e1.employee_id
        from employees e1
       where exists(
                select e2.salary
                  from employees e2
                 where e2.salary &lt; co_salary
             )
   )
   loop
      my_package.my_proc(in_employee_id =&gt; r_emp.employee_id);
   end loop emp_loop;
end;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-8120</key>
		<name><![CDATA[G-8120: Never check existence of a row to decide whether to create it or not.]]></name>
		<internalKey>G-8120</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The result of an existence check is a snapshot of the current situation. You never know whether
			in the time between the check and the (insert) action someone else has decided to create a row
			with the values you checked. Therefore, you should only rely on constraints when it comes to
			prevention of duplicate records.</p>
			<h2>Bad</h2>
<pre>create or replace package body department_api is
   procedure ins(in_r_department in departments%rowtype) is
      l_count pls_integer;
   begin
      select count(*)
        into l_count
        from departments
       where department_id = in_r_department.department_id;

      if l_count = 0 then
         insert into departments
         values in_r_department;
      end if;
   end ins;
end department_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body department_api is
   procedure ins(in_r_department in departments%rowtype) is
   begin
      insert into departments
      values in_r_department;
   exception
      when dup_val_on_index then
         null; -- handle exception
   end ins;
end department_api;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-8210</key>
		<name><![CDATA[G-8210: Always use synonyms when accessing objects of another application schema.]]></name>
		<internalKey>G-8210</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>If a connection is needed to a table that is placed in a foreign schema, using synonyms is a good
			choice. If there are structural changes to that table (e.g. the table name changes or the table
			changes into another schema) only the synonym has to be changed no changes to the package
			are needed (single point of change). If you only have read access for a table inside another
			schema, or there is another reason that does not allow you to change data in this table, you can
			switch the synonym to a table in your own schema. This is also good practice for testers working
			on test systems.</p>
			<h2>Bad</h2>
<pre>declare
   l_product_name oe.products.product_name%type;
   co_price       constant oe.products@list_price%type := 1000;
begin
   select p.product_name
     into l_product_name
     from oe.products p
    where list_price &gt; co_price;
exception
   when no_data_found then
      null; -- handle_no_data_found;
   when too_many_rows then
      null; -- handle_too_many_rows;
end;
/</pre>
			<h2>Good</h2>
<pre>create synonym oe_products for oe.products;

declare
   l_product_name oe_products.product_name%type;
   co_price       constant oe_products.list_price%type := 1000;
begin
   select p.product_name
     into l_product_name
     from oe_products p
    where list_price &gt; co_price;
exception
   when no_data_found then
      null; -- handle_no_data_found;
   when too_many_rows then
      null; -- handle_too_many_rows;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-8310</key>
		<name><![CDATA[G-8310: Always validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit.]]></name>
		<internalKey>G-8310</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>This technique raises an error (<code>value_error</code>) which may not be handled in the called program
			unit. This is the right way to do it, as the error is not within this unit but when calling it, so the
			caller should handle the error.</p>
			<h2>Bad</h2>
<pre>create or replace package body department_api is
   function dept_by_name(in_dept_name in departments.department_name%type)
      return departments%rowtype is
      r_return departments%rowtype;
   begin
      if in_dept_name is null or length(in_dept_name) &gt; 20 then
         raise err.e_param_to_large;
      end if;
      -- get the department by name
      select *
        into r_return
        from departments
       where department_name = in_dept_name;

      return r_return;
   end dept_by_name;
end department_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body department_api is
   function dept_by_name(in_dept_name in departments.department_name%type)
      return departments%rowtype is
      l_dept_name departments.department_name%type not null := in_dept_name;
      r_return    departments%rowtype;
   begin
      -- get the department by name
      select *
        into r_return
        from departments
       where department_name = l_dept_name;

      return r_return;
   end dept_by_name;
end department_api;
/

-- The exception should be handled where the function is called, like this:
begin
   pre_processing;
   r_department := department_api.dept_by_name('Far to long name of a department');
   post_processing;
exception
   when value_error then
      handle_error;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-8410</key>
		<name><![CDATA[G-8410: Always use application locks to ensure a program unit is only running once at a given time. (not implemented)]]></name>
		<internalKey>G-8410</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>This technique allows us to have locks across transactions as well as a proven way to clean up
			at the end of the session.</p>
			<p>The alternative using a table where a “Lock-Row” is stored has the disadvantage that in case of
			an error a proper cleanup has to be done to “unlock” the program unit.</p>
			<h2>Bad</h2>
<pre>/* Example */
create or replace package body lock_up is
   -- manage locks in a dedicated table created as follows:
   --   CREATE TABLE app_locks (
   --      lock_name VARCHAR2(128 CHAR) NOT NULL primary key
   --   );

   procedure request_lock(in_lock_name in varchar2) is
   begin
      -- raises dup_val_on_index
      insert into app_locks (lock_name) values (in_lock_name);
   end request_lock;

   procedure release_lock(in_lock_name in varchar2) is
   begin
      delete from app_locks where lock_name = in_lock_name;
   end release_lock;
end lock_up;
/

/* Call bad example */
declare
   co_lock_name constant varchar2(30 char) := 'APPLICATION_LOCK';
begin
   lock_up.request_lock(in_lock_name =&gt; co_lock_name);
   -- processing
   lock_up.release_lock(in_lock_name =&gt; co_lock_name);
exception
   when others then
      -- log error
      lock_up.release_lock(in_lock_name =&gt; co_lock_name);
      raise;
end;
/</pre>
			<h2>Good</h2>
<pre>/* Example */
create or replace package body lock_up is
   function request_lock(
      in_lock_name         in varchar2
     ,in_release_on_commit in boolean := false)
      return varchar2 is
      l_lock_handle varchar2(128 char);
   begin
      sys.dbms_lock.allocate_unique(
         lockname        =&gt; in_lock_name
        ,lockhandle      =&gt; l_lock_handle
        ,expiration_secs =&gt; constants_up.co_one_week
      );
      if sys.dbms_lock.request(
            lockhandle        =&gt; l_lock_handle
           ,lockmode          =&gt; sys.dbms_lock.x_mode
           ,timeout           =&gt; sys.dbms_lock.maxwait
           ,release_on_commit =&gt; coalesce(in_release_on_commit,false)
         ) &gt; 0
      then
         raise err.e_lock_request_failed;
      end if;
      return l_lock_handle;
   end request_lock;

   procedure release_lock(in_lock_handle in varchar2) is
   begin
      if sys.dbms_lock.release(lockhandle =&gt; in_lock_handle) &gt; 0 then
         raise err.e_lock_request_failed;
      end if;
   end release_lock;
end lock_up;
/

/* Call good example */
declare
   l_handle     varchar2(128 char);
   co_lock_name constant varchar2(30 char) := 'APPLICATION_LOCK';
begin
   l_handle := lock_up.request_lock(in_lock_name =&gt; co_lock_name);
   -- processing
   lock_up.release_lock(in_lock_handle =&gt; l_handle);
exception
   when others then
      -- log error
      lock_up.release_lock(in_lock_handle =&gt; l_handle);
      raise;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-8510</key>
		<name><![CDATA[G-8510: Always use dbms_application_info to track program process transiently. (not implemented)]]></name>
		<internalKey>G-8510</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>This technique allows us to view progress of a process without having to persistently write log
			data in either a table or a file. The information is accessible through the <code>v$session</code> view.</p>
			<h2>Bad</h2>
<pre>create or replace package body employee_api is
   procedure process_emps is
   begin
      &lt;&lt;employees&gt;&gt;
      for emp_rec in (
         select employee_id
           from employees
          order by employee_id
      )
      loop
         null; -- some processing
      end loop employees;
   end process_emps;
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api is
   procedure process_emps is
   begin
      sys.dbms_application_info.set_module(module_name =&gt; $$plsql_unit
                                          ,action_name =&gt; 'Init');
      &lt;&lt;employees&gt;&gt;
      for emp_rec in (
         select employee_id
           from employees
          order by employee_id
      )
      loop
         sys.dbms_application_info.set_action('Processing ' || emp_rec.employee_id);
      end loop employees;
   end process_emps;
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9010</key>
		<name><![CDATA[G-9010: Always use a format model in string to date/time conversion functions.]]></name>
		<internalKey>G-9010</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Converting from strings to <code>date</code> or <code>timestamp</code> datatypes (using <code>to_date</code>, <code>to_timestamp</code>,
			<code>to_timestamp_tz</code> or cast to any of those datatypes) in practice always expects a fixed format
			(unlike converting to strings that can be fixed as well as allow the session to decide). Therefore it
			is a bad idea to allow this conversion to rely on the session NLS settings (<code>nls_date_format</code>,
			<code>nls_timestamp_format</code> and <code>nls_timestamp_tz_format</code>) as this makes the code vulnerable to
			changes in session and/or server configuration. It is even possible to utilize session
			<code>nls_date_format</code> for SQL injection if you use dynamic SQL.</p>
			<p>Using an explicit format model for string to <code>date</code> or <code>timestamp</code> conversion avoids this
			inappropriate dependability on configurable NLS parameters.</p>
			<h2>Bad</h2>
<pre>create or replace package body employee_api is
   procedure set_dob(in_employee_id in employees.employee_id%type
                    ,in_dob_str     in varchar2) is
   begin
      update employees
         set date_of_birth = to_date(in_dob_str)
       where employee_id = in_employee_id;
   end set_dob;
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api is
   procedure set_dob(in_employee_id in employees.employee_id%type
                    ,in_dob_str     in varchar2) is
   begin
      update employees
         set date_of_birth = to_date(in_dob_str,'YYYY-MM-DD')
       where employee_id = in_employee_id;
   end set_dob;
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9020</key>
		<name><![CDATA[G-9020: Try to use a format model and NLS_NUMERIC_CHARACTERS in string to number conversion functions.]]></name>
		<internalKey>G-9020</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Converting from strings to numeric datatypes (using <code>to_number</code>, <code>to_binary_double</code>,
			<code>to_binary_float</code> or cast to any of those datatypes) rely on session NLS settings for
			<code>nls_numeric_characters</code>. Typically the input string is expected to have a given decimal- and
			group-separator, so it is best practice to specify <code>nls_numeric_characters</code> in the function call.
			However, this requires also setting a format model, which is a good idea but can require a very
			large format model with many 9's if you do not know the maximum length of the string.</p>
			<p>To avoid an inappropriate dependability on configurable NLS parameters, try to use both format
			model and <code>nls_numeric_characters</code> in the conversion function call. The exceptions can be if
			the input is known to always be integer with no decimal- or group-separator, or if you do not know
			the maximum number of digits and have control over the session <code>nls_numeric_characters</code>
			parameter.</p>
			<h2>Bad</h2>
<pre>create or replace package body employee_api is
   procedure set_salary(in_employee_id in employees.employee_id%type
                       ,in_salary      in varchar2) is
   begin
      update employees
         set salary = to_number(in_salary)
       where employee_id = in_employee_id;
   end set_dob;
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api is
   procedure set_salary(in_employee_id in employees.employee_id%type
                       ,in_salary      in varchar2) is
   begin
      update employees
         set salary = to_number(in_salary,'99999999999999999999.99999',q'[nls_numeric_characters='.,']')
       where employee_id = in_employee_id;
   end set_dob;
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-9030</key>
		<name><![CDATA[G-9030: Try to define a default value on conversion errors.]]></name>
		<internalKey>G-9030</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Restriction</h2>
			<p>Oracle Database 12c Release 2</p>
			<h2>Reason</h2>
			<p>When converting from strings to other datatypes using a conversion function that supports the
			<code>default ... on conversion error</code> clause, it is a good idea to use this clause to avoid getting
			an error raised on bad input. The exception can be when you explicitly want an error to be raised
			to catch and process it in a later exception handler.</p>
			<h2>Bad</h2>
<pre>create or replace package body employee_api is
   procedure set_dob(in_employee_id in employees.employee_id%type
                    ,in_dob_str     in varchar2) is
   begin
      update employees
         set date_of_birth = to_date(in_dob_str,'YYYY-MM-DD')
       where employee_id = in_employee_id;
   end set_dob;
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api is
   procedure set_dob(in_employee_id in employees.employee_id%type
                    ,in_dob_str     in varchar2) is
   begin
      update employees
         set date_of_birth = to_date(in_dob_str default null on conversion error,'YYYY-MM-DD')
       where employee_id = in_employee_id;
   end set_dob;
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-9040</key>
		<name><![CDATA[G-9040: Try using FX in string to date/time conversion format model to avoid fuzzy conversion.]]></name>
		<internalKey>G-9040</internalKey>
		<severity>MINOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The default string-to-date conversion rules allow fuzzy conversion when converting from strings
			to date or timestamp datatypes (using to_date, to_timestamp, to_timestamp_tz or cast to
			any of those datatypes). For example you can omit punctuation characters, use any non-alphanumeric
			character for punctuation, use month name instead of number, or various other rules.</p>
			<p>In practice you almost always expect a truly fixed format and want the database to enforce the
			format model and raise an error if the data does not match the format model. This you can
			achieve by adding the format modifier FX (format exact).</p>
			<p>The exception to this rule can be if you are converting textual input typed by a user, in which case
			the fuzzy conversion may be what you want.</p>
			<h2>Bad</h2>
<pre>create or replace package body employee_api is
   procedure set_dob(in_employee_id in employees.employee_id%type
                    ,in_dob_str     in varchar2) is
   begin
      update employees
         set date_of_birth = to_date(in_dob_str,'YYYY-MM-DD')
       where employee_id = in_employee_id;
   end set_dob;
end employee_api;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body employee_api is
   procedure set_dob(in_employee_id in employees.employee_id%type
                    ,in_dob_str     in varchar2) is
   begin
      update employees
         set date_of_birth = to_date(in_dob_str,'FXYYYY-MM-DD')
       where employee_id = in_employee_id;
   end set_dob;
end employee_api;
/</pre>
			<p></p>]]></description>
		<tag>try</tag>
	</rule>
	<rule>
		<key>G-9101</key>
		<name><![CDATA[G-9101: Always prefix global variables with 'g_'.]]></name>
		<internalKey>G-9101</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>create or replace package body example as
   some_name integer;
end example;
/</pre>
			<h2>Good</h2>
<pre>create or replace package body example as
   g_some_name integer;
end example;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9102</key>
		<name><![CDATA[G-9102: Always prefix local variables with 'l_'.]]></name>
		<internalKey>G-9102</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>declare
   some_name integer;
begin
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   l_some_name integer;
begin
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9103</key>
		<name><![CDATA[G-9103: Always prefix cursors with 'c_'.]]></name>
		<internalKey>G-9103</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>declare
   l_dept sys_refcursor;
begin
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   c_dept sys_refcursor;
begin
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9104</key>
		<name><![CDATA[G-9104: Always prefix records with 'r_'.]]></name>
		<internalKey>G-9104</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>declare
   emp  emp%rowtype;
   type r_dept_type is record(
         deptno number,
         dname  varchar2(14 char),
         loc    loc(13 char)
      );
   dept r_dept_type;
begin
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   r_emp  emp%rowtype;
   type r_dept_type is record(
         deptno number,
         dname  varchar2(14 char),
         loc    loc(13 char)
      );
   r_dept r_dept_type;
begin
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9105</key>
		<name><![CDATA[G-9105: Always prefix collection types (arrays/tables) with 't_'.]]></name>
		<internalKey>G-9105</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>declare
   type t_varray_type is varray(10) of string;
   array1 t_varray_type;
   type t_nested_table_type is table of string;
   array2 t_nested_table_type;
   type t_assoc_array_type is table of string index by pls_integer;
   array3 t_assoc_array_type;
begin
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   type t_varray_type is varray(10) of string;
   t_array1 t_varray_type;
   type t_nested_table_type is table of string;
   t_array2 t_nested_table_type;
   type t_assoc_array_type is table of string index by pls_integer;
   t_array3 t_assoc_array_type;
begin
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9106</key>
		<name><![CDATA[G-9106: Always prefix objects with 'o_'.]]></name>
		<internalKey>G-9106</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>create or replace type dept_type as object (
   deptno integer,
   dname  varchar2(14 char),
   loc    varchar2(13 char)
);
/

declare
   dept dept_type;
begin
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>create or replace type dept_type as object (
   deptno integer,
   dname  varchar2(14 char),
   loc    varchar2(13 char)
);
/

declare
   o_dept dept_type;
begin
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9107</key>
		<name><![CDATA[G-9107: Always prefix cursor parameters with 'p_'.]]></name>
		<internalKey>G-9107</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>declare
   cursor c_emp(in_ename in varchar2) is
      select *
        from emp
       where ename like in_ename;
begin
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   cursor c_emp(p_ename in varchar2) is
      select *
        from emp
       where ename like p_ename;
begin
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9108</key>
		<name><![CDATA[G-9108: Always prefix in parameters with 'in_'.]]></name>
		<internalKey>G-9108</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>create or replace package p is
   procedure p2(param in integer);
end p;
/</pre>
			<h2>Good</h2>
<pre>create or replace package p is
   procedure p2(in_param in integer);
end p;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9109</key>
		<name><![CDATA[G-9109: Always prefix out parameters with 'out_'.]]></name>
		<internalKey>G-9109</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>create or replace package p is
   procedure p2(param out integer);
end p;
/</pre>
			<h2>Good</h2>
<pre>create or replace package p is
   procedure p2(out_param out integer);
end p;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9110</key>
		<name><![CDATA[G-9110: Always prefix in/out parameters with 'io_'.]]></name>
		<internalKey>G-9110</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>create or replace package p is
   procedure p2(param in out integer);
end p;
/</pre>
			<h2>Good</h2>
<pre>create or replace package p is
   procedure p2(io_param in out integer);
end p;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9111</key>
		<name><![CDATA[G-9111: Always prefix record type definitions with 'r_' and add the suffix '_type'.]]></name>
		<internalKey>G-9111</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>declare
   type dept_typ is
      record(
         deptno number,
         dname  varchar2(14 char),
         loc    loc(13 char)
      );
begin
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   type r_dept_type is
      record(
         deptno number,
         dname  varchar2(14 char),
         loc    loc(13 char)
      );
begin
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9112</key>
		<name><![CDATA[G-9112: Always prefix collection type definitions (arrays/tables) with 't_' and add the suffix '_type'.]]></name>
		<internalKey>G-9112</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>declare
   type t_varray is varray(10) of string;
   type nested_table_type is table of string;
   type x_assoc_array_y is table of string index by pls_integer;
begin
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   type t_varray_type is varray(10) of string;
   type t_nested_table_type is table of string;
   type t_assoc_array_type is table of string index by pls_integer;
begin
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9113</key>
		<name><![CDATA[G-9113: Always prefix exceptions with 'e_'.]]></name>
		<internalKey>G-9113</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>declare
   some_name exception;
begin
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   e_some_name exception;
begin
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9114</key>
		<name><![CDATA[G-9114: Always prefix constants with 'co_'.]]></name>
		<internalKey>G-9114</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>declare
   maximum constant integer := 1000;
begin
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   co_maximum constant integer := 1000;
begin
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9115</key>
		<name><![CDATA[G-9115: Always prefix subtypes with '_type'.]]></name>
		<internalKey>G-9115</internalKey>
		<severity>MAJOR</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>See <a href="https://trivadis.github.io/plsql-and-sql-coding-guidelines/v4.2/2-naming-conventions/naming-conventions/#naming-conventions-for-plsql" target="_blank">Naming Conventions for PL/SQL</a>.</p>
			<h2>Bad</h2>
<pre>declare
   subtype short_text is varchar2(100 char);
begin
   null;
end;
/</pre>
			<h2>Good</h2>
<pre>declare
   subtype short_text_type is varchar2(100 char);
begin
   null;
end;
/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9501</key>
		<name><![CDATA[G-9501: Never use parameter in string expression of dynamic SQL. Use asserted local variable instead.]]></name>
		<internalKey>G-9501</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The use of static SQL eliminates the risk of SQL injection. However, if you write
			dynamic SQL you are responsible to ensure that the SQL cannot be injected with malicious
			SQL statements.</p>
			<p><p>
			
			<p>This check looks for unasserted parameters used in <code>execute immediate</code> statements
			and <code>open for</code> statements. All parameters used in these statements must be asserted with
			one of the subprograms provided by <code>dbms_assert</code>.</p>
			<h2>Bad</h2>
<pre>-- The input parameter in_table_name is copied to the local variable l_table_name and then used
-- without an assert to build the l_sql variable. Hence, the execute immediate statement is
-- considered vulnerable to SQL injection, e.g. by passing DEPT CASCADE CONSTRAINTS.
create or replace package body pkg is
    function f (in_table_name in varchar2) return boolean as
        co_templ     constant varchar2(4000 byte) := 'DROP TABLE #in_table_name# PURGE';
        l_table_name varchar2(128 byte);
        l_sql        varchar2(4000 byte);
    begin
        l_table_name := in_table_name;
        l_sql := replace(co_templ, '#in_table_name#', l_table_name);
        execute immediate l_sql;
        return true;
    end f;
end pkg;
/</pre>
			<h2>Good</h2>
<pre>-- SQL injection is not possible, because the input parameter in_table_name is 
-- checked/modified with sys.dbms_assert.enquote_name.
create or replace package body pkg is
    function f (in_table_name in varchar2) return boolean as
        co_templ     constant varchar2(4000 byte) := 'DROP TABLE #in_table_name# PURGE';
        l_table_name varchar2(128 byte);
        l_sql        varchar2(4000 byte);
    begin
        l_table_name := sys.dbms_assert.enquote_name(in_table_name);
        l_sql := replace(co_templ, '#in_table_name#', l_table_name);
        execute immediate l_sql;
        return true;
    end f;
end pkg;
/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-9600</key>
		<name><![CDATA[G-9600: Never define more than one comment with hints.]]></name>
		<internalKey>G-9600</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Only the first comment containing hints is considered by the Oracle Database, 
			therefore all hints violating this rule are treated as ordinary comments.</p>
			<h2>Bad</h2>
<pre>select -- a comment
       /*+ full(e) */
       /* another comment */
       --+ full(d)
       e.empno,
       e.ename,
       d.dname
  from emp e
  join dept d
    on d.deptno = e.deptno
 where empno &gt; 7900;
 
select * from dbms_xplan.display_cursor(format =&gt; 'basic +hint_report');

/*
------------------------------------------------
| Id  | Operation                    | Name    |
------------------------------------------------
|   0 | SELECT STATEMENT             |         |
|   1 |  NESTED LOOPS                |         |
|   2 |   NESTED LOOPS               |         |
|   3 |    TABLE ACCESS FULL         | EMP     |
|   4 |    INDEX UNIQUE SCAN         | PK_DEPT |
|   5 |   TABLE ACCESS BY INDEX ROWID| DEPT    |
------------------------------------------------
 
Hint Report (identified by operation id / Query Block Name / Object Alias):
Total hints for statement: 1
---------------------------------------------------------------------------
 
   3 -  SEL$58A6D7F6 / E@SEL$1
           -  full(e)
*/</pre>
			<h2>Better</h2>
<pre>select -- a comment
       /*+ full(e) full(d) */
       /* another comment */
       e.empno,
       e.ename,
       d.dname
  from emp e
  join dept d
    on d.deptno = e.deptno
 where empno &gt; 7900;
 
select * from dbms_xplan.display_cursor(format =&gt; 'basic +hint_report');

/*
-----------------------------------
| Id  | Operation          | Name |
-----------------------------------
|   0 | SELECT STATEMENT   |      |
|   1 |  HASH JOIN         |      |
|   2 |   TABLE ACCESS FULL| EMP  |
|   3 |   TABLE ACCESS FULL| DEPT |
-----------------------------------
 
Hint Report (identified by operation id / Query Block Name / Object Alias):
Total hints for statement: 2
---------------------------------------------------------------------------
 
   2 -  SEL$58A6D7F6 / E@SEL$1
           -  full(e)
 
   3 -  SEL$58A6D7F6 / D@SEL$1
           -  full(d)
*/</pre>
			<h2>Good</h2>
<pre>-- do not mix single-line and mult-line comments
-- use hints first or hints last, do not hide them within other comments
select --+ full(e) full(d)
       -- a comment
       -- another comment
       e.empno,
       e.ename,
       d.dname
  from emp e
  join dept d
    on d.deptno = e.deptno
 where empno &gt; 7900;

select * from dbms_xplan.display_cursor(format =&gt; 'basic +hint_report');

/*
-----------------------------------
| Id  | Operation          | Name |
-----------------------------------
|   0 | SELECT STATEMENT   |      |
|   1 |  HASH JOIN         |      |
|   2 |   TABLE ACCESS FULL| EMP  |
|   3 |   TABLE ACCESS FULL| DEPT |
-----------------------------------
 
Hint Report (identified by operation id / Query Block Name / Object Alias):
Total hints for statement: 2
---------------------------------------------------------------------------
 
   2 -  SEL$58A6D7F6 / E@SEL$1
           -  full(e)
 
   3 -  SEL$58A6D7F6 / D@SEL$1
           -  full(d)
*/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-9601</key>
		<name><![CDATA[G-9601: Never use unknown hints.]]></name>
		<internalKey>G-9601</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Using unknown hints might invalidate all subsequent hints. 
			This happens when you use for example NOLOGGING. That's expected
			and not a bug. See MOS note 285285.1 or bug 8432870 for details.</p>
			<h2>Bad</h2>
<pre>-- "nologging" is not a hint. It does not exist in v$sql_hint.
-- The "append" hint is ignored as a result "LOAD TABLE CONVENTIONAL" is applied.
insert --+ nologging append
  into sales_hist
select * from sales;

select * from dbms_xplan.display_cursor(format =&gt; 'basic');

/*
-----------------------------------------------
| Id  | Operation                | Name       |
-----------------------------------------------
|   0 | INSERT STATEMENT         |            |
|   1 |  LOAD TABLE CONVENTIONAL | SALES_HIST |
|   2 |   PARTITION RANGE ALL    |            |
|   3 |    TABLE ACCESS FULL     | SALES      |
-----------------------------------------------
*/</pre>
			<h2>Good</h2>
<pre>-- "nologging" is applied on the table, however this is in most 
-- environments overridden by the force logging option on database level.
-- The "append" hint is applied, as a result "LOAD AS SELECT" is applied.
alter table sales_hist nologging;

insert --+ append
  into sales_hist
select * from sales;

select * from dbms_xplan.display_cursor(format =&gt; 'basic');

/*
-------------------------------------------------------
| Id  | Operation                        | Name       |
-------------------------------------------------------
|   0 | INSERT STATEMENT                 |            |
|   1 |  LOAD AS SELECT                  | SALES_HIST |
|   2 |   OPTIMIZER STATISTICS GATHERING |            |
|   3 |    PARTITION RANGE ALL           |            |
|   4 |     TABLE ACCESS FULL            | SALES      |
-------------------------------------------------------
*/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-9602</key>
		<name><![CDATA[G-9602: Always use the alias name instead of the table name.]]></name>
		<internalKey>G-9602</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p> There are various hints that reference a table or view. Typically, if an alias is defined
			for a table/view, but the table/view name is used in the hint, then the hint is
			ignored by the Oracle Database.</p>
			<h2>Bad</h2>
<pre>select --+ leading(emp dept)
       *
  from emp e
  join dept d on d.deptno = e.deptno;

select * from dbms_xplan.display_cursor(format =&gt; 'basic +hint_report');

/*
------------------------------------------------
| Id  | Operation                    | Name    |
------------------------------------------------
|   0 | SELECT STATEMENT             |         |
|   1 |  MERGE JOIN                  |         |
|   2 |   TABLE ACCESS BY INDEX ROWID| DEPT    |
|   3 |    INDEX FULL SCAN           | PK_DEPT |
|   4 |   SORT JOIN                  |         |
|   5 |    TABLE ACCESS FULL         | EMP     |
------------------------------------------------
 
Hint Report (identified by operation id / Query Block Name / Object Alias):
Total hints for statement: 1 (U - Unused (1))
---------------------------------------------------------------------------
 
   1 -  SEL$58A6D7F6
         U -  leading(emp dept)
*/</pre>
			<h2>Good</h2>
<pre>select --+ leading(e d)
       *
  from emp e
  join dept d on d.deptno = e.deptno;

select * from dbms_xplan.display_cursor(format =&gt; 'basic +hint_report');

/*
-----------------------------------
| Id  | Operation          | Name |
-----------------------------------
|   0 | SELECT STATEMENT   |      |
|   1 |  HASH JOIN         |      |
|   2 |   TABLE ACCESS FULL| EMP  |
|   3 |   TABLE ACCESS FULL| DEPT |
-----------------------------------
 
Hint Report (identified by operation id / Query Block Name / Object Alias):
Total hints for statement: 1
---------------------------------------------------------------------------
 
   1 -  SEL$58A6D7F6
           -  leading(e d)
*/</pre>
			<p></p>]]></description>
		<tag>always</tag>
	</rule>
	<rule>
		<key>G-9603</key>
		<name><![CDATA[G-9603: Never reference an unknown table/alias.]]></name>
		<internalKey>G-9603</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p> There are various hints that reference a table or view. If the table or
			view reference in the hint is neither a table name nor an alias, then the hint
			is ignored by the Oracle Database.</p>
			<h2>Bad</h2>
<pre>select --+ leading(emps depts)
       *
  from emp
  join dept on emp.deptno = dept.deptno;

select * from dbms_xplan.display_cursor(format =&gt; 'basic +hint_report');

/*
------------------------------------------------
| Id  | Operation                    | Name    |
------------------------------------------------
|   0 | SELECT STATEMENT             |         |
|   1 |  MERGE JOIN                  |         |
|   2 |   TABLE ACCESS BY INDEX ROWID| DEPT    |
|   3 |    INDEX FULL SCAN           | PK_DEPT |
|   4 |   SORT JOIN                  |         |
|   5 |    TABLE ACCESS FULL         | EMP     |
------------------------------------------------
 
Hint Report (identified by operation id / Query Block Name / Object Alias):
Total hints for statement: 1 (U - Unused (1))
---------------------------------------------------------------------------
 
   1 -  SEL$58A6D7F6
         U -  leading(emps depts)
*/</pre>
			<h2>Good</h2>
<pre>select --+ leading(emp dept)
       *
  from emp
  join dept on emp.deptno = dept.deptno;

select * from dbms_xplan.display_cursor(format =&gt; 'basic +hint_report');

/*
-----------------------------------
-----------------------------------
| Id  | Operation          | Name |
-----------------------------------
|   0 | SELECT STATEMENT   |      |
|   1 |  HASH JOIN         |      |
|   2 |   TABLE ACCESS FULL| EMP  |
|   3 |   TABLE ACCESS FULL| DEPT |
-----------------------------------
 
Hint Report (identified by operation id / Query Block Name / Object Alias):
Total hints for statement: 1
---------------------------------------------------------------------------
 
   1 -  SEL$58A6D7F6
           -  leading(emp dept)
*/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-9604</key>
		<name><![CDATA[G-9604: Never use an invalid stats method.]]></name>
		<internalKey>G-9604</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The syntax for the gather_stats hints is:</p>
			<pre>table_stats([&lt;schema&gt;.]&lt;table&gt; &lt;method&gt; [,] &lt;keyword&gt;=&lt;value&gt; [[,] &lt;keyword&gt;=&lt;value&gt;]...)</pre>
			<p>Valid methods are:</p>
			<ul>
			   <li>DEFAULT</li>
			   <li>SET</li>
			   <li>SCALE</li>
			   <li>SAMPLE</li>
			</ul>
			<p>The Oracle Database treats other methods as a syntax error and will ignore the hint.</p>
			<h2>Bad</h2>
<pre>select /*+ table_stats(emp faster rows=14) */ empno, ename
  from emp e
 where deptno = 20;
select * from dbms_xplan.display_cursor(format =&gt; 'basic +hint_report');  

/*
----------------------------------
| Id  | Operation         | Name |
----------------------------------
|   0 | SELECT STATEMENT  |      |
|   1 |  TABLE ACCESS FULL| EMP  |
----------------------------------
 
Hint Report (identified by operation id / Query Block Name / Object Alias):
Total hints for statement: 1 (E - Syntax error (1))
---------------------------------------------------------------------------
 
   1 -  SEL$1
         E -  table_stats
*/</pre>
			<h2>Good</h2>
<pre>select /*+ table_stats(emp set rows=14) */ empno, ename
  from emp e
 where deptno = 20;
select * from dbms_xplan.display_cursor(format =&gt; 'basic +hint_report');

/*
----------------------------------
| Id  | Operation         | Name |
----------------------------------
|   0 | SELECT STATEMENT  |      |
|   1 |  TABLE ACCESS FULL| EMP  |
----------------------------------
 
Hint Report (identified by operation id / Query Block Name / Object Alias):
Total hints for statement: 1
---------------------------------------------------------------------------
 
   0 -  STATEMENT
           -  table_stats(emp set rows=14)
*/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>G-9605</key>
		<name><![CDATA[G-9605: Never use an invalid stats keyword.]]></name>
		<internalKey>G-9605</internalKey>
		<severity>CRITICAL</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>The syntax for the gather_stats hints is:</p>
			<pre>table_stats([&lt;schema&gt;.]&lt;table&gt; &lt;method&gt; [,] &lt;keyword&gt;=&lt;value&gt; [[,] &lt;keyword&gt;=&lt;value&gt;]...)</pre>
			<p>Valid keywords are:</p>
			<ul>
			   <li>ROWS</li>
			   <li>BLOCKS</li>
			   <li>ROW_LENGTH</li>
			</ul>
			<p>The Oracle Database treats other keywords as a syntax error and will ignore the hint.</p>
			<h2>Bad</h2>
<pre>select /*+ table_stats(emp default rec=14 blk=1 rowlen=10) */ empno, ename
  from emp e
 where deptno = 20;
select * from dbms_xplan.display_cursor(format =&gt; 'basic +hint_report');  

/*
----------------------------------
| Id  | Operation         | Name |
----------------------------------
|   0 | SELECT STATEMENT  |      |
|   1 |  TABLE ACCESS FULL| EMP  |
----------------------------------
 
Hint Report (identified by operation id / Query Block Name / Object Alias):
Total hints for statement: 1 (E - Syntax error (1))
---------------------------------------------------------------------------
 
   1 -  SEL$1
         E -  table_stats
*/</pre>
			<h2>Good</h2>
<pre>select /*+ table_stats(emp default rows=14 blocks=1 row_length=10) */ empno, ename
  from emp e
 where deptno = 20;
select * from dbms_xplan.display_cursor(format =&gt; 'basic +hint_report');

/*
----------------------------------
| Id  | Operation         | Name |
----------------------------------
|   0 | SELECT STATEMENT  |      |
|   1 |  TABLE ACCESS FULL| EMP  |
----------------------------------
 
Hint Report (identified by operation id / Query Block Name / Object Alias):
Total hints for statement: 1
---------------------------------------------------------------------------
 
   0 -  STATEMENT
           -  table_stats(emp set rows=14)
*/</pre>
			<p></p>]]></description>
		<tag>never</tag>
	</rule>
	<rule>
		<key>E-0001</key>
		<name>E-0001: Timeout occurred (after n seconds) during load/parse/validation of resource.</name>
		<internalKey>E-0001</internalKey>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>Processing large SQL files takes time. Increase the db* CODECOP timeout parameter to avoid this error. The default timeout per file is 10 seconds.</p>
		]]></description>
		<tag>error</tag>
	</rule>
	<rule>
		<key>E-0002</key>
		<name>E-0002: Syntax error. Please contact the author if the code compiles successfully in your environment.</name>
		<internalKey>E-0002</internalKey>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>It's either a db* CODECOP bug or a <a href="https://github.com/Trivadis/plsql-cop-cli/blob/master/parser-limitations.md">limitation</a>, if the code compiles successfully in your environment.</p>
			<p>Please note, that syntax errors may lead to false positives. db* CODECOP will therefore not report guideline violations, if a syntax error was encountered in the processed file.</p>
		]]></description>
		<tag>error</tag>
	</rule>
	<rule>
		<key>E-0003</key>
		<name>E-0003: License limit reached.</name>
		<internalKey>E-0003</internalKey>
		<severity>BLOCKER</severity>
		<cardinality>SINGLE</cardinality>
		<status>READY</status>
		<description><![CDATA[
			<h2>Reason</h2>
			<p>A db* CODECOP license key defines limitations for the number of files, lines, commands and bytes to be processed. Please contact your Trivadis representative to obtain a less restrictive license.</p>
		]]></description>
		<tag>error</tag>
	</rule>
</rules>
